<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Csharp Introduction</title>
    <url>/jaheel.github.io/2020/10/19/C%20sharp%20Introduction/</url>
    <content><![CDATA[<h1 id="C-sharp-Introduction"><a href="#C-sharp-Introduction" class="headerlink" title="C sharp Introduction"></a>C sharp Introduction</h1><h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1 特性"></a>1 特性</h2><p>面向对象、面向组件</p>
<p><strong>垃圾回收：</strong>自动回收未使用的对象占用的内存</p>
<p><strong>异常处理：</strong>一种结构化的可扩展方法用于错误检测和恢复</p>
<p><strong>类型安全：</strong>不可能从未初始化的变量中进行读取，将数组索引在其边界之外，或者执行未检查的类型转换。</p>
<p><strong>统一类型系统：</strong>所有C#类型（包括int和double等基元类型）均继承自一个根object类型。</p>
<a id="more"></a>

<h2 id="2-类型"><a href="#2-类型" class="headerlink" title="2 类型"></a>2 类型</h2><h3 id="2-1-值类型"><a href="#2-1-值类型" class="headerlink" title="2.1 值类型"></a>2.1 值类型</h3><p>直接包含数据</p>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>枚举类型</th>
<th>结构类型</th>
<th>可以为null的类型</th>
</tr>
</thead>
<tbody><tr>
<td>sbyte</td>
<td>enum E{…}</td>
<td>struct S{…}</td>
<td>值为null的其他所有值类型的扩展</td>
</tr>
<tr>
<td>short</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>int</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>long</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ushort</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>uint</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ulong</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>char</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>float</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>double</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>decimal</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-2-引用类型"><a href="#2-2-引用类型" class="headerlink" title="2.2 引用类型"></a>2.2 引用类型</h3><p>存储对象的引用</p>
<table>
<thead>
<tr>
<th>类类型</th>
<th>接口类型</th>
<th>数组类型</th>
<th>委托类型</th>
</tr>
</thead>
<tbody><tr>
<td>object</td>
<td>interface I{…}</td>
<td>int[]</td>
<td>delegate int D(…)</td>
</tr>
<tr>
<td>string</td>
<td></td>
<td>int[,]</td>
<td></td>
</tr>
<tr>
<td>class C{…}</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-语句"><a href="#3-语句" class="headerlink" title="3 语句"></a>3 语句</h2><table>
<thead>
<tr>
<th>选择语句</th>
<th>迭代语句</th>
<th>跳转语句</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>if</td>
<td>while</td>
<td>break</td>
<td>try…catch</td>
</tr>
<tr>
<td>switch</td>
<td>do</td>
<td>continue</td>
<td>try…finally</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>goto</td>
<td>checked</td>
</tr>
<tr>
<td></td>
<td>foreach</td>
<td>throw</td>
<td>unchecked</td>
</tr>
<tr>
<td></td>
<td></td>
<td>return</td>
<td>lock</td>
</tr>
<tr>
<td></td>
<td></td>
<td>yield</td>
<td>using</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h2><h3 id="4-1-成员"><a href="#4-1-成员" class="headerlink" title="4.1 成员"></a>4.1 成员</h3><p>常量、字段、方法、属性、索引器、事件、运算符、构造函数、析构函数、类型</p>
<h3 id="4-2-可访问性"><a href="#4-2-可访问性" class="headerlink" title="4.2 可访问性"></a>4.2 可访问性</h3><p>public、protected、internal、protected internal、private</p>
<h3 id="4-3-参数"><a href="#4-3-参数" class="headerlink" title="4.3 参数"></a>4.3 参数</h3><p>值参数、引用参数(ref)、输出参数(out)、输入参数(in)、参数数组(params)</p>
<h3 id="4-4-virtual、override、abstract"><a href="#4-4-virtual、override、abstract" class="headerlink" title="4.4 virtual、override、abstract"></a>4.4 virtual、override、abstract</h3><p>虚方法：运行时类型决定(virtual)</p>
<p>重写虚方法(override)</p>
<p>抽象方法：无实现的虚方法(abstract)</p>
<blockquote>
<p>只允许在abstract类中使用，必须在所有非抽象派生类中重写抽象方法</p>
</blockquote>
]]></content>
      <categories>
        <category>Csharp</category>
      </categories>
      <tags>
        <tag>Csharp</tag>
        <tag>code</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言笔记</title>
    <url>/jaheel.github.io/2020/10/19/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习自：C语言中文网</p>
<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h1><h2 id="1-1-字符编码"><a href="#1-1-字符编码" class="headerlink" title="1.1 字符编码"></a>1.1 字符编码</h2><table>
<thead>
<tr>
<th>字符编码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td>只显示英文字符（基本拉丁字母）</td>
</tr>
<tr>
<td>GB2312</td>
<td>简体中文字符集，1980年发布</td>
</tr>
<tr>
<td>GBK</td>
<td>中文字符集，在GB2312基础上扩展，1995年发布</td>
</tr>
<tr>
<td>GB18030</td>
<td>中文字符集，GBK的再扩展，2000年发布</td>
</tr>
<tr>
<td>Big5</td>
<td>繁体中文字符集，台湾、香港地区</td>
</tr>
<tr>
<td>ISO/IEC 8859</td>
<td>欧洲字符集（ASCII的扩展）</td>
</tr>
<tr>
<td>Unicode</td>
<td>统一码，万国码</td>
</tr>
</tbody></table>
<a id="more"></a>

<table>
<thead>
<tr>
<th>Unicode方案</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>UTF-8</td>
<td>变长编码方案，使用1~6个字节存储</td>
</tr>
<tr>
<td>UTF-32</td>
<td>固定长度编码方案，始终4个字节</td>
</tr>
<tr>
<td>UTF-16</td>
<td>使用2or4个字节存储</td>
</tr>
</tbody></table>
<h2 id="1-2-编译（Compile）、链接（Link）"><a href="#1-2-编译（Compile）、链接（Link）" class="headerlink" title="1.2 编译（Compile）、链接（Link）"></a>1.2 编译（Compile）、链接（Link）</h2><p>编译器（Compiler）</p>
<p>编译：将程序转换成计算机能够识别的二进制文件</p>
<p>链接器（Linker）</p>
<p>链接：将目标文件(Object File)和系统组件（比如标准库、动态链接库等）结合起来。</p>
<h2 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h2><table>
<thead>
<tr>
<th>说明</th>
<th>数据类型</th>
<th>数据长度</th>
</tr>
</thead>
<tbody><tr>
<td>字符型</td>
<td>char</td>
<td>1</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>4</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>无类型</td>
<td>void</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-4-常用库"><a href="#1-4-常用库" class="headerlink" title="1.4 常用库"></a>1.4 常用库</h2><h3 id="1-4-1-stdio-h"><a href="#1-4-1-stdio-h" class="headerlink" title="1.4.1 stdio.h"></a>1.4.1 stdio.h</h3><p>全称：standard input and output</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>();<span class="comment">//output string,自动换行</span></span><br><span class="line">gets();<span class="comment">//获取字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>();<span class="comment">//获取输入</span></span><br><span class="line"><span class="built_in">printf</span>();<span class="comment">//print format,格式化输出，换行须在后方加&#x27;/n&#x27; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>();<span class="comment">//获取某个数据类型的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">putchar</span>(a);<span class="comment">//输出单个字符</span></span><br><span class="line">getchar();<span class="comment">//获取一个字符</span></span><br><span class="line"></span><br><span class="line">fflush(<span class="built_in">stdout</span>);<span class="comment">//清空缓冲区</span></span><br></pre></td></tr></table></figure>



<h3 id="1-4-2-wchar-h"><a href="#1-4-2-wchar-h" class="headerlink" title="1.4.2 wchar.h"></a>1.4.2 wchar.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> a = <span class="string">L&#x27;A&#x27;</span>;  <span class="comment">//英文字符（基本拉丁字符）</span></span><br><span class="line"><span class="keyword">wchar_t</span> b = <span class="string">L&#x27;9&#x27;</span>;  <span class="comment">//英文数字（阿拉伯数字）</span></span><br><span class="line"><span class="keyword">wchar_t</span> c = <span class="string">L&#x27;中&#x27;</span>;  <span class="comment">//中文汉字</span></span><br><span class="line"><span class="keyword">wchar_t</span> d = <span class="string">L&#x27;国&#x27;</span>;  <span class="comment">//中文汉字</span></span><br><span class="line"><span class="keyword">wchar_t</span> e = <span class="string">L&#x27;。&#x27;</span>;  <span class="comment">//中文标点</span></span><br><span class="line"><span class="keyword">wchar_t</span> f = <span class="string">L&#x27;ヅ&#x27;</span>;  <span class="comment">//日文片假名</span></span><br><span class="line"><span class="keyword">wchar_t</span> g = <span class="string">L&#x27;♥&#x27;</span>;  <span class="comment">//特殊符号</span></span><br><span class="line"><span class="keyword">wchar_t</span> h = <span class="string">L&#x27;༄&#x27;</span>;  <span class="comment">//藏文</span></span><br></pre></td></tr></table></figure>



<h3 id="1-4-3-conio-h"><a href="#1-4-3-conio-h" class="headerlink" title="1.4.3 conio.h"></a>1.4.3 conio.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能用于windows平台</span></span><br><span class="line">getche();<span class="comment">//输入一个字符后立即读取，不用等待用户按下回车键，界面显示这个字符</span></span><br><span class="line">getch();<span class="comment">//立即读取输入的单个字符，不显示</span></span><br></pre></td></tr></table></figure>



<h3 id="1-4-4-string-h"><a href="#1-4-4-string-h" class="headerlink" title="1.4.4 string.h"></a>1.4.4 string.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(arrayName1,arrayName2);<span class="comment">//string catenate,把两个字符串拼接在一起</span></span><br><span class="line"><span class="built_in">strcpy</span>(arrayName1,arrayName2);<span class="comment">//字符串复制</span></span><br><span class="line"><span class="built_in">strcmp</span>(arrayName1,arrayName2);<span class="comment">//字符串比较</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-指针"><a href="#2-指针" class="headerlink" title="2 指针"></a>2 指针</h1><p>&amp;：取地址</p>
<p>*：指向地址</p>
<p>*(&amp;a)=a</p>
<p>&amp;(*pa)=pa</p>
<table>
<thead>
<tr>
<th>定  义</th>
<th>含  义</th>
</tr>
</thead>
<tbody><tr>
<td>int *p;</td>
<td>p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。</td>
</tr>
<tr>
<td>int **p;</td>
<td>p 为二级指针，指向 int * 类型的数据。</td>
</tr>
<tr>
<td>int *p[n];</td>
<td>p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]);</td>
</tr>
<tr>
<td>int (*p)[n];</td>
<td>p 为<a href="http://c.biancheng.net/c/array/">二维数组</a>指针。</td>
</tr>
<tr>
<td>int *p();</td>
<td>p 是一个函数，它的返回值类型为 int *。</td>
</tr>
<tr>
<td>int (*p)();</td>
<td>p 是一个函数指针，指向原型为 int func() 的函数。</td>
</tr>
</tbody></table>
<h1 id="3-结构体"><a href="#3-结构体" class="headerlink" title="3 结构体"></a>3 结构体</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">    结构体所包含的变量或数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues = <span class="number">2</span>, Wed = <span class="number">3</span>, Thurs = <span class="number">4</span>, Fri = <span class="number">5</span>, Sat = <span class="number">6</span>, Sun = <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> 共用体名&#123;</span></span><br><span class="line">    成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位域：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> m;<span class="comment">//4个字节Byte</span></span><br><span class="line">    <span class="keyword">unsigned</span> n: <span class="number">4</span>;<span class="comment">//4bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ch: <span class="number">6</span>;<span class="comment">//6bit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-知识点补充"><a href="#4-知识点补充" class="headerlink" title="4 知识点补充"></a>4 知识点补充</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> oldName newName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ARRAY20[<span class="number">20</span>];</span><br><span class="line">ARRAY20 a1, a2, s1, s2;<span class="comment">//等价于char a1[20], a2[20], s1[20], s2[20];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出 max:20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PTR_TO_FUNC pfunc = max;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max: %d\n&quot;</span>, (*pfunc)(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxNum=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;<span class="comment">//指针指向的数据只读</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2;<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3;<span class="comment">//指针自身的值不能被修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针本身和它指向的数据都是只读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p4;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p5;</span><br></pre></td></tr></table></figure>

<p>随机数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));<span class="comment">//重新播种</span></span><br><span class="line">   a = rand();<span class="comment">//依据种子和正态分布产生随机数</span></span><br></pre></td></tr></table></figure>

<h1 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h1><p>FILE是&lt;stdio.h&gt;头文件中的一个结构体，专门保存文件信息</p>
<h2 id="5-1-fopen"><a href="#5-1-fopen" class="headerlink" title="5.1 fopen()"></a>5.1 fopen()</h2><p>fopen()获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个FILE类型的结构体变量中，然后将该变量的地址返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;demo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//只读</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;D:\\demo.txt&quot;</span>,<span class="string">&quot;rb+&quot;</span>);<span class="comment">//读和写</span></span><br></pre></td></tr></table></figure>



<p>判断文件是否打开成功</p>
<blockquote>
<p>fopen()打开错误返回值是NULL</p>
</blockquote>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“r”</td>
<td>以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。</td>
</tr>
<tr>
<td>“w”</td>
<td>以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。</td>
</tr>
<tr>
<td>“a”</td>
<td>以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。</td>
</tr>
<tr>
<td>“r+”</td>
<td>以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。</td>
</tr>
<tr>
<td>“w+”</td>
<td>以“写入/更新”方式打开文件，相当于<code>w</code>和<code>r+</code>叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。</td>
</tr>
<tr>
<td>“a+”</td>
<td>以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。</td>
</tr>
</tbody></table>
<h2 id="5-2-fclose"><a href="#5-2-fclose" class="headerlink" title="5.2 fclose()"></a>5.2 fclose()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-字符形式读写文件"><a href="#5-3-字符形式读写文件" class="headerlink" title="5.3 字符形式读写文件"></a>5.3 字符形式读写文件</h2><h3 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc()"></a>fgetc()</h3><p>file get char</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//fp为文件指针，fgetc()读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF(end of file)</span></span><br></pre></td></tr></table></figure>

<h3 id="fputc"><a href="#fputc" class="headerlink" title="fputc()"></a>fputc()</h3><p>file put char</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span> <span class="params">( <span class="keyword">int</span> ch, FILE *fp )</span></span>;</span><br><span class="line"><span class="comment">//ch为要写入的字符，fp为文件指针</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-字符串形式读写文件"><a href="#5-4-字符串形式读写文件" class="headerlink" title="5.4 字符串形式读写文件"></a>5.4 字符串形式读写文件</h2><h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><p>file get string</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> n, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//str为字符数组，n为要读取的字符数目，fp为文件指针</span></span><br><span class="line"><span class="comment">//遇见换行符结束读取</span></span><br></pre></td></tr></table></figure>

<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><p>file put string</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">char</span> *str, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//str为要写入的字符串，fp为文件指针。写入成功返回非负数，失败返回EOF</span></span><br></pre></td></tr></table></figure>

<h2 id="5-5-数据块形式读写文件"><a href="#5-5-数据块形式读写文件" class="headerlink" title="5.5 数据块形式读写文件"></a>5.5 数据块形式读写文件</h2><p>fread()和fwrite()时应该以二进制形式打开文件</p>
<h3 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size,<span class="keyword">size_t</span> count, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ptr:内存区块的指针</span></span><br><span class="line"><span class="comment">size:表示每个数据块的字节数</span></span><br><span class="line"><span class="comment">count:表示要读写的数据块的块数</span></span><br><span class="line"><span class="comment">fp:表示文件指针</span></span><br><span class="line"><span class="comment">返回值:返回成功读写的块数，也即count</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>对于 fread() 来说，可能读到了文件末尾，可能发生了错误，可以用 ferror() 或 feof() 检测</p>
<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a>fwrite()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span> <span class="params">( <span class="keyword">void</span> * ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于 fwrite() 来说，肯定发生了写入错误，可以用 ferror() 函数检测。</p>
<h2 id="5-6-格式化读写文件"><a href="#5-6-格式化读写文件" class="headerlink" title="5.6 格式化读写文件"></a>5.6 格式化读写文件</h2><p>fscanf()和fprintf()的读写对象不是键盘和显示器，而是磁盘文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span> <span class="params">( FILE *fp, <span class="keyword">char</span> * format, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span> <span class="params">( FILE *fp, <span class="keyword">char</span> * format, ... )</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-7-随机读写文件"><a href="#5-7-随机读写文件" class="headerlink" title="5.7 随机读写文件"></a>5.7 随机读写文件</h2><p>rewind()用来将位置指针移动到文件开头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fseek()用来将位置指针移动到任意位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> origin)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>fp：文件指针</li>
<li>offset：偏移量，也就是要移动的字节数</li>
<li>origin：起始位置</li>
</ol>
<h2 id="5-8-ftell"><a href="#5-8-ftell" class="headerlink" title="5.8 ftell()"></a>5.8 ftell()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//用来获取文件内部指针（位置指针）距离文件开头的字节数</span></span><br></pre></td></tr></table></figure>

<h1 id="6-内存分区"><a href="#6-内存分区" class="headerlink" title="6 内存分区"></a>6 内存分区</h1><table>
<thead>
<tr>
<th>内存分区</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序代码区 (code)</td>
<td>存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。</td>
</tr>
<tr>
<td>常量区 (constant)</td>
<td>存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。</td>
</tr>
<tr>
<td>全局数据区 (global data)</td>
<td>存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。</td>
</tr>
<tr>
<td>堆区 (heap)</td>
<td>一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。<a href="http://c.biancheng.net/cpp/html/137.html">malloc()</a>、<a href="http://c.biancheng.net/cpp/html/134.html">calloc()</a>、<a href="http://c.biancheng.net/cpp/html/135.html">free()</a> 等函数操作的就是这块内存，这也是本章要讲解的重点。  注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。</td>
</tr>
<tr>
<td>动态链接库</td>
<td>用于在程序运行期间加载和卸载动态链接库。</td>
</tr>
<tr>
<td>栈区 (stack)</td>
<td>存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。</td>
</tr>
</tbody></table>
<h2 id="6-1-栈和堆的区别"><a href="#6-1-栈和堆的区别" class="headerlink" title="6.1 栈和堆的区别"></a>6.1 栈和堆的区别</h2><p>栈区：系统分配和释放，不受程序员控制</p>
<p>堆区：完全由程序员掌控，自主可控</p>
<h2 id="6-2-动态内存分配函数"><a href="#6-2-动态内存分配函数" class="headerlink" title="6.2 动态内存分配函数"></a>6.2 动态内存分配函数</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>原型：void* malloc(size_t size);</p>
<p>作用：在堆区分配 size 字节的内存空间。</p>
<p>返回值：成功返回分配的内存地址，失败则返回NULL。</p>
<p>注意：分配内存在动态存储区（堆区），手动分配，手动释放，申请时空间可能有也可能没有，需要自行判断，由于返回的是void*，建议手动强制类型转换。</p>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><p>原型：void* calloc(size_t n, size_t size);</p>
<p>功能：在堆区分配 n*size 字节的连续空间。</p>
<p>返回值：成功返回分配的内存地址，失败则返回NULL。</p>
<p>注意：calloc() 函数是对 malloc() 函数的简单封装，参数不同，使用时务必小心，第一参数是第二参数的单元个数，第二参数是单位的字节数。</p>
<h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc()"></a>realloc()</h3><p>原型：void* realloc(void *ptr, size_t size);</p>
<p>功能：对 ptr 指向的内存重新分配 size 大小的空间，size 可比原来的大或者小，还可以不变（如果你无聊的话）。</p>
<p>返回值：成功返回更改后的内存地址，失败则返回NULL。</p>
<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>原型：void free(void* ptr);</p>
<p>功能：释放由 malloc()、calloc()、realloc() 申请的内存空间。</p>
<h1 id="7-Socket"><a href="#7-Socket" class="headerlink" title="7 Socket"></a>7 Socket</h1><ol>
<li>Windows下socket程序依赖Winsock.dll或ws2_32.dll，必须提前加载。</li>
<li>Windows使用“文件句柄”概念，区分socket文件和普通文件；socket（）返回值为SOCKET类型（即句柄）</li>
<li>Windows下使用recv()/send()函数发送和接收</li>
<li>关闭socket时，Windows使用closesocket()函数</li>
</ol>
<h2 id="7-1-socket"><a href="#7-1-socket" class="headerlink" title="7.1 socket()"></a>7.1 socket()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line"><span class="comment">//SOCK_STREAM:TCP SOCK_DGRAM:UDP</span></span><br></pre></td></tr></table></figure>

<h2 id="7-2-bind"><a href="#7-2-bind" class="headerlink" title="7.2 bind()"></a>7.2 bind()</h2><p>服务器端：将套接字与特定的IP地址和端口绑定起来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(SOCKET sock, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sock:socket文件描述符</span></span><br><span class="line"><span class="comment">addr:sockaddr结构体变量的指针</span></span><br><span class="line"><span class="comment">addrlen:addr变量的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="7-3-connect"><a href="#7-3-connect" class="headerlink" title="7.3 connect()"></a>7.3 connect()</h2><p>客户端：用connect()函数建立连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(SOCKET sock, <span class="keyword">const</span> struct sockaddr *serv_addr, <span class="keyword">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-4-listen"><a href="#7-4-listen" class="headerlink" title="7.4 listen()"></a>7.4 listen()</h2><p>让套接字进入被动监听状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(SOCKET sock, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sock:需要进入监听状态的套接字</span></span><br><span class="line"><span class="comment">backlog:请求队列的最大长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="7-5-accept"><a href="#7-5-accept" class="headerlink" title="7.5 accept()"></a>7.5 accept()</h2><p>套接字处于监听状态时，可以通过accept()函数接收客户端请求</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(SOCKET sock, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;  <span class="comment">//Windows</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sock:服务器端套接字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-6-数据接收和发送"><a href="#7-6-数据接收和发送" class="headerlink" title="7.6 数据接收和发送"></a>7.6 数据接收和发送</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET sock, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sock:要发送数据的套接字</span></span><br><span class="line"><span class="comment">buf:要发送的数据的缓冲区地址</span></span><br><span class="line"><span class="comment">len:要发送的数据的字节数</span></span><br><span class="line"><span class="comment">flags:发送数据时的选项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET sock, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>base</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer English</title>
    <url>/jaheel.github.io/2020/10/19/Computer%20English/</url>
    <content><![CDATA[<h2 id="1-专有名词"><a href="#1-专有名词" class="headerlink" title="1 专有名词"></a>1 专有名词</h2><p>computer 计算机</p>
<p>computer science 计算机科学</p>
<p>overview 概述</p>
<p>automation 自动化 </p>
<p>compile v. 汇编，编译</p>
<p>Analytical Engine 分析机，解析机</p>
<p>Difference Engine 差分机</p>
<p>prototype n.原型，样机</p>
<p>memory n.存储器，内存</p>
<p>transistor n.晶体管</p>
<a id="more"></a>

<p>logical element 逻辑元件</p>
<p>spacing n.间隔</p>
<p>integrated circuit 集成电路(IC)</p>
<p>microprocessor n.微处理器</p>
<p>microchip n.微芯片</p>
<p>etch v. 蚀刻</p>
<p>instruction set 指令集</p>
<p>workstation n.工作站</p>
<p>mainframe n.主机，大型机</p>
<p>supercomputer n.超级计算机，巨型计算机</p>
<p>bus:总线</p>
<p>numerical analysis : 数值分析</p>
<p>life cycle 生命周期，生存周期</p>
<p>image processing  图像处理</p>
<p>signal processing 信号处理</p>
<p>speech recognition 语音识别</p>
<p>natural language understanding 自然语言处理</p>
<p>computer vision 计算机视觉</p>
<p>robotics 机器人技术</p>
<p>handheld computer 手持式计算机，掌上电脑</p>
<p>Web site 网站，站点</p>
<p>compact disc 光盘</p>
<p>floppy disk 软盘</p>
<p>rigid disk 硬盘</p>
<p>address bus 地址总线</p>
<p>data bus 数据总线</p>
<p>shell 外壳，命令解释程序</p>
<p>kernal 内核，内核程序</p>
<p>mass storage 海量存储器，大容量存储器</p>
<p>extension 扩展，扩展名</p>
<p>directory path 目录路径</p>
<p>descriptor 描述符，解说符</p>
<p>peripheral devices 外围设备</p>
<p>status word 状态字</p>
<p>time slice 时间片</p>
<p>backup 备份</p>
<p>protocol 协议</p>
<p>integrated user interface 综合用户接口</p>
<p>assembly language 汇编语言</p>
<p>intermediate language 中间语言</p>
<p>statement 语句</p>
<p>assignment statement 赋值语句</p>
<p>conditional statement 条件语句</p>
<p>function statement 函数语句</p>
<p>class hierarchy 类层次</p>
<p>inheritance 继承性</p>
<p>encapsulation 封装性</p>
<p>polymorphism 多态性</p>
<p>bounds checking 边界检查</p>
<p>flowchart 流程图</p>
<p>source file 源文件</p>
<p>object code 目标代码</p>
<p>data flow diagram 数据流程图</p>
<p>entity relationship diagram 实体关系图</p>
<p>multicast protocol 多址通信协议</p>
<p>loosely coupled system 松散耦合系统</p>
<p>tightly coupled system 紧密耦合系统</p>
<p>cost effectiveness 成本效益</p>
<p>waterfall model 瀑布模型</p>
<p>black box testing 黑盒测试</p>
<p>white box testing 白盒测试</p>
<p>regression test 回归测试</p>
<p>exercising test 压力测试</p>
<p>data mining 数据挖掘</p>
<p>coaxial cable 同轴电缆</p>
<p>dotted decimal notation 点分十进制记数法</p>
<p>cloud computing 云计算</p>
<p>trust delegation 信任委托</p>
<p>data coloring 数据着色</p>
<p>antivirus software 杀毒软件</p>
<p>malicious software 恶意软件</p>
<p>maintenance hook 维护陷阱</p>
<p>word processor 文字处理软件</p>
<p>spreadsheet program 电子数据表程序</p>
<p>presentation software 演示软件</p>
<p>electronic commerce 电子商务</p>
<h2 id="2-简称"><a href="#2-简称" class="headerlink" title="2 简称"></a>2 简称</h2><p>CPU: Central Processing Unit 中央处理器</p>
<p>AI: artificial intelligence 人工智能</p>
<p>NN: neural network 神经网络</p>
<p>VR: virtual reality 虚拟现实</p>
<p>BIOS : Basic Input/Output System 基本输入/输出系统</p>
<p>CRT : Cathode Ray Tube 阴极射线管</p>
<p>LCD : Liquid Crystal Display 液晶显示器</p>
<p>RAM : Random-access Memory 随机存储器</p>
<p>ROM : Read-only Memory 只读存储器</p>
<p>GUI  : graphical user interface 图形用户界面</p>
<p>SQL : Structured Query Language 结构化查询语言</p>
<p>MDD : Model Driven Development 模型驱动开发</p>
<p>IE : Information Engineering 信息工程</p>
<p>OOAD : Object-Oriented Analysis and Design 面向对象分析与设计</p>
<p>TCP/IP : Transmission Control Protocol/ Internet Protocol 传输控制/网际协议</p>
<p>HTTP : Hypertext Transfer Protocol 超文本传输协议</p>
<p>WWW : World Wide Web 互联网</p>
<p>ISO : International Organization for Standardization</p>
<p>ANSI : American National Standards Institute</p>
<p>CBSE : Component-based software engineering 基于组件的软件工程</p>
<p>DBMS : database management system 数据库管理系统</p>
<p>DBAs : database administrators 数据库管理员</p>
<p>RDBMS : relational database management system 关系数据库管理系统</p>
<p>ERM : entity-relationship model 实体关系模型</p>
<p>LAN : local area network </p>
<p>MAN : metropolitan area network</p>
<p>WAN : wide area network</p>
<p>CSMA/CD : Carrier Sense Multiple Access with Collision Detection  带有冲突检测的载波侦听多路访问协议</p>
<p>TLD : top-level domain 顶级域名</p>
<p>DNS : domain name system 域名系统</p>
<p>SaaS : Software as a Service 软件即服务</p>
<p>IT : information technology 信息技术</p>
<p>GAE : Google App Engine 谷歌应用引擎</p>
<p>AWS : Amazon Web Services 亚马逊网络服务</p>
<p>IoT : The Internet of Things 物联网</p>
<p>RFID : radio-frequency identification </p>
<p>CIA : confidentiality, integrity, and availability 机密性、完整性、可用性</p>
<p>gif : Graphics Interchange Format 图形交换格式</p>
<p>SSL : Seure Sockets Layer 安全套接层</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>profession</tag>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/jaheel.github.io/2020/10/19/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h2><p>Python3.8.1</p>
<p>安装opencv-python</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>



<h2 id="1-1-测试"><a href="#1-1-测试" class="headerlink" title="1.1 测试"></a>1.1 测试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line">image = cv2.imread(<span class="string">&quot;1.jpg&quot;</span>, <span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image&quot;</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)//使画面停留，避免闪退</span><br></pre></td></tr></table></figure>



<h2 id="2-模块"><a href="#2-模块" class="headerlink" title="2 模块"></a>2 模块</h2><table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Core</td>
<td>该模块包含 OpenCV 库的基础结构以及基本操作。</td>
</tr>
<tr>
<td>Improc</td>
<td>图像处理模块包含基本的图像转换，包括滤波以及类似的卷积操作。</td>
</tr>
<tr>
<td>Highgui</td>
<td>在 OpenCV 3.0中，分割为 imcodecs、videoio 以及 highgui 三部分。  这个模块包含可以用来显示图像或者简单的输入的用户交互函数。这可以看作是一个非常轻量级的 Windows UI 工具包。</td>
</tr>
<tr>
<td>Video</td>
<td>该模块包含读取和写视频流的函数。</td>
</tr>
<tr>
<td>Calib3d</td>
<td>这个模块包括校准单个、双目以及多个相机的算法实现。</td>
</tr>
<tr>
<td>Feature2d</td>
<td>这个模块包含用于检测、描述以及匹配特征点的算法。</td>
</tr>
<tr>
<td>Objdectect</td>
<td>这个模块包含检测特定目标，比如人脸或者行人的算法。也可以训练检测器并用来检测其他物体。</td>
</tr>
<tr>
<td>Ml</td>
<td>机器学习模块本身是一个非常完备的模块，包含大量的机器学习算法实现并且这些算法都能和 OpenCV 的数据类型自然交互。</td>
</tr>
<tr>
<td>Flann</td>
<td>Flann 的意思是“快速最邻近库”。这个库包含一些你也许不会直接使用的方法，但是其他模块中的函数会调用它在数据集中进行最邻近搜索。</td>
</tr>
<tr>
<td>GPU</td>
<td>在 OpenCV 中被分割为多个 cuda* 模块。  GPU 模块主要是函数在 CUDA GPU 上的优化实现，此外，还有一些仅用于 GPU 的功 能。其中一些函数能够返回很好的结果，但是需要足够好的计算资源，如果硬件没有GPU，则不会有什么提升。</td>
</tr>
<tr>
<td>Photo</td>
<td>这是一个相当新的模块，包含计算摄影学的一些函数工具。</td>
</tr>
<tr>
<td>Stitching</td>
<td>本模块是一个精巧的图像拼接流程实现。这是库中的新功能，但是，就像 Photo 模块一样，这个领域未来预计有很大的增长。</td>
</tr>
<tr>
<td>Nonfree</td>
<td>在 OpenCV 3.0 中，被移到 opencv_contrib/xfeatures2d。  OpenCV 包含一些受到专利保护的或者受到使用限制的（比如 SIFT 算法）算法。这些算法被隔离到它们自己的模块中，以表明你需要做一些特殊的工作，才可以在商业产品中使用它们。</td>
</tr>
<tr>
<td>Contrib</td>
<td>在 OpenCV 3.0 中，融合进了 opencv_contrib。  这个模块包含一些新的、还没有被集成进 OpenCV 库的东西。</td>
</tr>
<tr>
<td>Legacy</td>
<td>在 OpenCV 3.0 中，被取消。  这个模块包含一些老的尚未被完全取消的东西。</td>
</tr>
<tr>
<td>ocl</td>
<td>在OpenCV 3.0 中，被取消，取而代之的是 T-API。  这是一个较新的模块，可以认为它和 GPU 模块相似，它实现了开放并行编程的 Khronos OpenCL 标准。虽然现在模块的特性比 GPU 模块少很多，但 ocl 模块的目标是提供可以运行在任何 GPU 或者是其他可以搭载 Khronos 的并行设备。这与 GPU 模 块形成了鲜明的对比，后者使用 Nividia CUDA 工具包进行开发，因此只能在 Nividia GPU 设备上工作。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Python_OS库</title>
    <url>/jaheel.github.io/2020/10/19/Python_OS_method/</url>
    <content><![CDATA[<h2 id="Python-os"><a href="#Python-os" class="headerlink" title="Python_os"></a>Python_os</h2><table>
<thead>
<tr>
<th>Method</th>
<th>usage</th>
</tr>
</thead>
<tbody><tr>
<td>os.chdir(path)</td>
<td>改变当前工作目录</td>
</tr>
<tr>
<td>os.chroot(path)</td>
<td>改变当前进程的根目录</td>
</tr>
<tr>
<td>os.close(fd)</td>
<td>关闭文件描述符fd</td>
</tr>
<tr>
<td>os.dup(fd)</td>
<td>复制文件描述符fd</td>
</tr>
<tr>
<td>os.dup2(fd,fd2)</td>
<td>将一个文件描述符fd复制到另一个fd2</td>
</tr>
<tr>
<td>os.link(src,dst)</td>
<td>创建硬链接，名为参数dst，指向参数src</td>
</tr>
<tr>
<td>os.listdir(path)</td>
<td>返回path指定文件夹中包含的文件或文件夹的名字的列表</td>
</tr>
<tr>
<td>os.open(file,flags[,mode])</td>
<td>打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td>os.pipe()</td>
<td>创建一个管道，返回一对文件描述符(r,w)分别为读和写</td>
</tr>
<tr>
<td>os.readlink(path)</td>
<td>返回软链接所指向的文件</td>
</tr>
<tr>
<td>os.remove(path)</td>
<td>删除路径为path的文件</td>
</tr>
<tr>
<td>os.removedirs(path)</td>
<td>递归删除目录</td>
</tr>
<tr>
<td>os.rename(src,dst)</td>
<td>重命名文件或目录，从src到dst</td>
</tr>
<tr>
<td>os.rmdir(path)</td>
<td>删除path指定的空目录，若非空，则抛出一个OSError异常</td>
</tr>
<tr>
<td>os.symlink(src,dst)</td>
<td>创建一个软链接</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="os-path-模块"><a href="#os-path-模块" class="headerlink" title="os.path()模块"></a>os.path()模块</h2><table>
<thead>
<tr>
<th>Method</th>
<th>usage</th>
</tr>
</thead>
<tbody><tr>
<td>os.path.abspath(path)</td>
<td>返回绝对路径</td>
</tr>
<tr>
<td>os.path.basename(path)</td>
<td>返回文件名</td>
</tr>
<tr>
<td>os.path.dirname(path)</td>
<td>返回文件路径</td>
</tr>
<tr>
<td>os.path.exists(path)</td>
<td>如果路径path存在，返回True;反之返回False</td>
</tr>
<tr>
<td>os.path.getatime(path)</td>
<td>返回最近访问时间</td>
</tr>
<tr>
<td>os.path.getmtime(path)</td>
<td>返回最近文件修改时间</td>
</tr>
<tr>
<td>os.path.getsize(size)</td>
<td>返回文件大小</td>
</tr>
<tr>
<td>os.path.isabs(path)</td>
<td>判断是否为绝对路径</td>
</tr>
<tr>
<td>os.path.isfile(path)</td>
<td>判断路径是否为文件</td>
</tr>
<tr>
<td>os.path.isdir(path)</td>
<td>判断路径是否为目录</td>
</tr>
<tr>
<td>os.path.islink(path)</td>
<td>判断路径是否为链接</td>
</tr>
<tr>
<td>os.path.join(path1,path2,…)</td>
<td>把目录和文件名合成一个路径</td>
</tr>
<tr>
<td>os.path.realpath(path)</td>
<td>返回path的真实路径</td>
</tr>
<tr>
<td>os.path.relpath(path,start)</td>
<td>从start开始计算相对路径</td>
</tr>
<tr>
<td>os.path.sameopenfile(fp1,fp2)</td>
<td>判断fp1和fp2是否指向同一文件</td>
</tr>
<tr>
<td>os.path.split(path)</td>
<td>把路径分割成dirname和basename，返回一个元组</td>
</tr>
<tr>
<td>os.path.splitdrive(path)</td>
<td>返回驱动器名和路径组成的元组</td>
</tr>
<tr>
<td>os.path.splitext(path)</td>
<td>返回路径名和文件扩展名的元组</td>
</tr>
<tr>
<td>os.path.walk(path,visit, arg)</td>
<td>遍历path,进入每个目录都调用visit函数，visit函数必须有3个参数(arg,dirname,names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Rider配置PlantUML</title>
    <url>/jaheel.github.io/2020/10/19/Rider%E9%85%8D%E7%BD%AEPlantUML/</url>
    <content><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>插件：</p>
<p>​        PlantUML4idea.zip </p>
<p>​        来源网站：<a href="https://plugins.jetbrains.com/plugin/7017-plantuml-integration/versions">https://plugins.jetbrains.com/plugin/7017-plantuml-integration/versions</a></p>
<p>图形编辑：</p>
<p>​        graphviz-2.38.msi(2.38为win10下稳定版)</p>
<p>​        来源网站：<a href="https://graphviz.gitlab.io/download/">https://graphviz.gitlab.io/download/</a></p>
<h1 id="嵌入Rider"><a href="#嵌入Rider" class="headerlink" title="嵌入Rider"></a>嵌入Rider</h1><ol>
<li>将graphviz-2.38.msi解压到指定文件夹，系统属性 <strong>环境变量 Path</strong>添加：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\graphviz\bin #换成解压后指定文件夹(此处是我自己的绝对路径)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>打开Rider，File-&gt;Setting-&gt;Plugins</p>
<p>将PlantUML4idea.zip从Disk中添加进来</p>
</li>
<li><p>重启Rider</p>
</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Rider中新建puml文件，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">testdot</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>结果显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installation seems OK. File generation OK #成功</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Rider</category>
      </categories>
      <tags>
        <tag>Rider</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Spider_Python Note</title>
    <url>/jaheel.github.io/2020/10/19/Spider_Python_Note/</url>
    <content><![CDATA[<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h2><h3 id="1-1-登陆网页"><a href="#1-1-登陆网页" class="headerlink" title="1.1 登陆网页"></a>1.1 登陆网页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">url=<span class="string">&quot;xxxxxx&quot;</span></span><br><span class="line">html = urlopen(url).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#decode()转换文字编码</span></span><br><span class="line"><span class="comment">#html即是往往也所有信息</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-匹配网页内容"><a href="#1-2-匹配网页内容" class="headerlink" title="1.2 匹配网页内容"></a>1.2 匹配网页内容</h3><p>假设找网页的title:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re <span class="comment">#正则表达式模块</span></span><br><span class="line">result=re.findall(<span class="string">r&quot;&lt;title&gt;(.+?)&lt;/title&gt;&quot;</span>,html)</span><br><span class="line">print(<span class="string">&quot;\nPage title is:&quot;</span>,result[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>找<p>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res =re.findall(<span class="string">r&quot;&lt;p&gt;(.+?)&lt;/p&gt;&quot;</span>,html,flags=re.DOTALL)<span class="comment"># flags设置对tab等不敏感</span></span><br></pre></td></tr></table></figure>

<h2 id="2-BeautifulSoup"><a href="#2-BeautifulSoup" class="headerlink" title="2 BeautifulSoup"></a>2 BeautifulSoup</h2><h3 id="2-1-用处"><a href="#2-1-用处" class="headerlink" title="2.1 用处"></a>2.1 用处</h3><p>BeautifulSoup包简化匹配方式，方便查询</p>
<h3 id="2-2-下载"><a href="#2-2-下载" class="headerlink" title="2.2 下载"></a>2.2 下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>

<h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, features=<span class="string">&#x27;lxml&#x27;</span>) <span class="comment"># html是上文读取的内容</span></span><br><span class="line">print(soup.h1)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>,soup.p)<span class="comment">#读取特定tag内容</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-官方文档"><a href="#2-4-官方文档" class="headerlink" title="2.4 官方文档"></a>2.4 官方文档</h3><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</a></p>
<h3 id="2-5-解析器"><a href="#2-5-解析器" class="headerlink" title="2.5  解析器"></a>2.5  解析器</h3><table>
<thead>
<tr>
<th>解析器</th>
<th>使用方法</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td>Python标准库</td>
<td>BeautifulSoup(markup, “html.parser”)</td>
<td>1. Python的内置标准库 2. 执行速度适中 3.文档容错能力强</td>
</tr>
<tr>
<td>lxml HTML解析器</td>
<td>BeautifulSoup(markup, “lxml”)</td>
<td>速度快、文档容错能力强</td>
</tr>
<tr>
<td>lxml XML解析器</td>
<td>BeautifulSoup(markup, “xml”)</td>
<td>速度快、唯一支持XML的解析器</td>
</tr>
<tr>
<td>html5lib</td>
<td>BeautifulSoup(markup, “html5lib”)</td>
<td>最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档</td>
</tr>
</tbody></table>
<h2 id="3-Requests库"><a href="#3-Requests库" class="headerlink" title="3 Requests库"></a>3 Requests库</h2><h2 id="4-Asyncio库"><a href="#4-Asyncio库" class="headerlink" title="4 Asyncio库"></a>4 Asyncio库</h2><h2 id="5-aiohttp库"><a href="#5-aiohttp库" class="headerlink" title="5 aiohttp库"></a>5 aiohttp库</h2><h2 id="6-学习网址"><a href="#6-学习网址" class="headerlink" title="6 学习网址"></a>6 学习网址</h2><p><a href="https://morvanzhou.github.io/tutorials/data-manipulation/scraping/3-01-requests/">https://morvanzhou.github.io/tutorials/data-manipulation/scraping/3-01-requests/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP学习笔记</title>
    <url>/jaheel.github.io/2020/10/19/TCP_IP/</url>
    <content><![CDATA[<p>学习自C语言中文网</p>
<h1 id="1-硬件组成"><a href="#1-硬件组成" class="headerlink" title="1 硬件组成"></a>1 硬件组成</h1><h2 id="1-1-网卡"><a href="#1-1-网卡" class="headerlink" title="1.1 网卡"></a>1.1 网卡</h2><p>也称网络适配器(Network Adapter)，连接计算机和传输介质的接口。</p>
<p>计算机数据转换为能够通过传输介质传输的信号。</p>
<h3 id="1-1-1-有线网卡"><a href="#1-1-1-有线网卡" class="headerlink" title="1.1.1 有线网卡"></a>1.1.1 有线网卡</h3><p>“线”指的是网线。</p>
<h3 id="1-1-2-无线网卡"><a href="#1-1-2-无线网卡" class="headerlink" title="1.1.2 无线网卡"></a>1.1.2 无线网卡</h3><p>无线信号连接。通常指Wi-Fi网络的无线网卡。</p>
<h3 id="1-1-3-蓝牙适配器"><a href="#1-1-3-蓝牙适配器" class="headerlink" title="1.1.3 蓝牙适配器"></a>1.1.3 蓝牙适配器</h3><p>与无线网卡的区别是数据通信方式不同。</p>
<h2 id="1-2-网络电缆"><a href="#1-2-网络电缆" class="headerlink" title="1.2 网络电缆"></a>1.2 网络电缆</h2><p>用来连接网络中的各个设备，供设备之间进行数据通信。</p>
<h3 id="1-2-1-双绞线"><a href="#1-2-1-双绞线" class="headerlink" title="1.2.1 双绞线"></a>1.2.1 双绞线</h3><p>两根具有绝缘保护层的铜导线缠绕组成</p>
<p>EIA/TIA 568B线序：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕</p>
<h3 id="1-2-2-光纤"><a href="#1-2-2-光纤" class="headerlink" title="1.2.2 光纤"></a>1.2.2 光纤</h3><p>传输光信号的细而柔软的媒质。</p>
<p>光纤两端的”光猫“进行信号转换。</p>
<h3 id="1-2-3-电话线"><a href="#1-2-3-电话线" class="headerlink" title="1.2.3 电话线"></a>1.2.3 电话线</h3><p>连接电话的线，线数比双绞线少</p>
<a id="more"></a>

<h2 id="1-3-网络设备"><a href="#1-3-网络设备" class="headerlink" title="1.3 网络设备"></a>1.3 网络设备</h2><p>网络组成中的设备</p>
<h3 id="1-3-1-交换机"><a href="#1-3-1-交换机" class="headerlink" title="1.3.1 交换机"></a>1.3.1 交换机</h3><p>可将多个网络设备连接组成一个局域网。</p>
<p>用于数据交换</p>
<h3 id="1-3-2-路由器"><a href="#1-3-2-路由器" class="headerlink" title="1.3.2 路由器"></a>1.3.2 路由器</h3><p>Router</p>
<p>又称网关设备(Gateway)</p>
<p>用于连接多个逻辑上分开的网络。</p>
<h3 id="1-3-3-调制解调器"><a href="#1-3-3-调制解调器" class="headerlink" title="1.3.3 调制解调器"></a>1.3.3 调制解调器</h3><p>Modem</p>
<p>俗称”猫”</p>
<h1 id="2-网络协议"><a href="#2-网络协议" class="headerlink" title="2 网络协议"></a>2 网络协议</h1><h2 id="2-1-TCP-IP"><a href="#2-1-TCP-IP" class="headerlink" title="2.1 TCP/IP"></a>2.1 TCP/IP</h2><p>前身：ARPANET</p>
<p>协议族：TCP、IP、ICMP、HTTP等</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为应用程序提供服务并规定应用程序中相关的通信细节。</td>
</tr>
<tr>
<td>传输层</td>
<td>为两台主机上的应用程序提供端到端的通信，提供流量控制、错误控制和确认服务。</td>
</tr>
<tr>
<td>网际层</td>
<td>提供独立于硬件的逻辑寻址，从而让数据能够在具有不同的物理结构的子网之间传递。负责寻找地址和路由选择的同时，网络层还可以实现拥塞控制、网际互联等功能。</td>
</tr>
<tr>
<td>网络访问层</td>
<td>提供了与物理网络连接的接口。针对传输介质设置数据格式，根据硬件的物理地址实现数据的寻址，对数据在物理网络中的传递提供错误控制。</td>
</tr>
</tbody></table>
<h2 id="2-2-OSI"><a href="#2-2-OSI" class="headerlink" title="2.2 OSI"></a>2.2 OSI</h2><table>
<thead>
<tr>
<th>层次</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为应用程序提供服务并规定应用程序中相关的通信细节。常见的协议包括超文本传输协议（HTTP）、简单邮件传送协议（SMTP）和远程登录（Telnet）协议等。</td>
</tr>
<tr>
<td>表示层</td>
<td>将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。该层主要负责数据格式的转换，确保一个系统的应用层信息可被另一个系统应用层读取。</td>
</tr>
<tr>
<td>会话层</td>
<td>负责建立和断开通信连接（数据流动的逻辑通路），以及记忆数据的分隔等数据传输相关的管理。</td>
</tr>
<tr>
<td>传输层</td>
<td>只在通信双方的节点上（比如计算机终端）进行处理，无须在路由器上处理。</td>
</tr>
<tr>
<td>网络层</td>
<td>将数据传输到目标地址，主要负责寻找地址和路由选择，网络层还可以实现拥塞控制、网际互联等功能。</td>
</tr>
<tr>
<td>数据链路层</td>
<td>负责物理层面上互连的节点间的通信传输。例如，一个以太网相连的两个节点之间的通信。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错和重发等。</td>
</tr>
<tr>
<td>物理层</td>
<td>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</td>
</tr>
</tbody></table>
<h1 id="3-学习工具"><a href="#3-学习工具" class="headerlink" title="3 学习工具"></a>3 学习工具</h1><h2 id="3-1-netwox"><a href="#3-1-netwox" class="headerlink" title="3.1 netwox"></a>3.1 netwox</h2><p>下载： <a href="https://sourceforge.net/projects/ntwox/">https://sourceforge.net/projects/ntwox/</a></p>
<p>网络包的生成</p>
<h2 id="3-2-wireshark"><a href="#3-2-wireshark" class="headerlink" title="3.2 wireshark"></a>3.2 wireshark</h2><p>下载： <a href="http://www.wireshark.org/">http://www.wireshark.org</a></p>
<p>网络包的分析</p>
<p>协议数据包 5个层次：</p>
<ul>
<li>Frame：物理层数据帧</li>
<li>Ethernet II：以太网帧头部</li>
<li>Internet Protocol Version 4：网际层IP包头部</li>
<li>TCP、UDP：传输层头部</li>
<li>HTTP、DNS、SSDP：应用层信息</li>
</ul>
<p>物理层：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netwox 169</span><br><span class="line">//查看物理、虚拟网络适配器的详情</span><br></pre></td></tr></table></figure>



<p>数据链路层：</p>
<ul>
<li><p>介质访问控制（Media Access Control，MAC）</p>
<blockquote>
<p>提供与网络适配器连接的接口</p>
</blockquote>
</li>
<li><p>逻辑链路控制（Logical Link Control，LLC）</p>
<blockquote>
<p>对经过子网传递的帧进行错误检查，并且管理子网上通信设备之间的链路</p>
</blockquote>
</li>
</ul>
<h1 id="4-层次协议"><a href="#4-层次协议" class="headerlink" title="4 层次协议"></a>4 层次协议</h1><h2 id="4-1-物理层"><a href="#4-1-物理层" class="headerlink" title="4.1 物理层"></a>4.1 物理层</h2><table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>前同步码</td>
<td>用来使接收端的适配器在接收 MAC 帧时能够迅速调整时钟频率，使它和发送端的频率相同。前同步码为 7 个字节，1 和 0 交替。</td>
</tr>
<tr>
<td>帧开始定界符</td>
<td>帧的起始符，为 1 个字节。前 6 位 1 和 0 交替，最后的两个连续的 1 表示告诉接收端适配器：“帧信息要来了，准备接收”。</td>
</tr>
</tbody></table>
<h2 id="4-2-MAC层"><a href="#4-2-MAC层" class="headerlink" title="4.2 MAC层"></a>4.2 MAC层</h2><p>MAC地址：48bit，前24bit特定厂商，后24bit为厂商自定</p>
<p>以太网帧（MAC帧）：</p>
<p>目的地址：6字节</p>
<p>源地址：6字节</p>
<p>类型：2字节</p>
<p>数据：46~1500字节</p>
<p>FCS：4字节</p>
<h2 id="4-3-IP层"><a href="#4-3-IP层" class="headerlink" title="4.3 IP层"></a>4.3 IP层</h2><p>探测局域网中所有主机的IP地址、主机名和MAC地址信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netwox 3 -a 192.168.0.0/24</span><br></pre></td></tr></table></figure>

<p>探测域名主机所有IP地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netwox 3 -a www.baidu.com</span><br></pre></td></tr></table></figure>

<p>构造IP数据报</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netwox 38</span><br></pre></td></tr></table></figure>



<h3 id="4-3-1-IP协议"><a href="#4-3-1-IP协议" class="headerlink" title="4.3.1 IP协议"></a>4.3.1 IP协议</h3><p>IP数据报头部：20字节</p>
<ol>
<li><p>版本：4bit</p>
</li>
<li><p>首部长度：4bit</p>
<blockquote>
<p>表示范围：0~15（十进制）</p>
<p>计算单位：4字节（表示15代表首部长度达到60字节）</p>
</blockquote>
</li>
<li><p>区分服务：8bit</p>
</li>
<li><p>总长度：16bit</p>
<blockquote>
<p>首部和数据之和</p>
<p>单位：字节</p>
<p>最大长度：2^16-1=65535字节</p>
</blockquote>
</li>
<li><p>标识：16bit</p>
<blockquote>
<p>具有相同的标识字段值的分片报文会被重组成原来的数据报</p>
</blockquote>
</li>
<li><p>标志：3bit</p>
<blockquote>
<p>第一位：0</p>
<p>第二位：DF（不分片）</p>
<p>第三位：MF（更多分片）</p>
</blockquote>
</li>
<li><p>片偏移：13bit</p>
<blockquote>
<p>计算单位：8字节</p>
</blockquote>
</li>
<li><p>生存时间：8bit</p>
</li>
<li><p>协议：8bit</p>
<blockquote>
<p>TCP：6</p>
<p>UDP：17</p>
<p>ICMP：1</p>
</blockquote>
</li>
<li><p>首部检验和：16bit</p>
<blockquote>
<p>校验数据报的首部，TTL发生变化，需重新计算</p>
</blockquote>
</li>
<li><p>源地址：32bit</p>
</li>
<li><p>目的地址：32bit</p>
</li>
</ol>
<h3 id="4-3-2-ICMP协议"><a href="#4-3-2-ICMP协议" class="headerlink" title="4.3.2 ICMP协议"></a>4.3.2 ICMP协议</h3><p>全称：Internet Control Message Protocol(控制报文协议)</p>
<p>报文结构（8字节）：</p>
<ol>
<li>类型：1字节</li>
<li>代码：1字节</li>
<li>校验和：2字节</li>
<li>不同类型和代码有不同的内容：4字节</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>回显应答（ping 应答）</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>网络不可达</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>主机不可达</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>协议不可达</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>端口不可达</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>需要进行分片，但设置不分片位</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>源站选路失败</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>目的网络未知</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>目的主机未知</td>
</tr>
<tr>
<td>3</td>
<td>9</td>
<td>目的网络被强制禁止</td>
</tr>
<tr>
<td>3</td>
<td>10</td>
<td>目的主机被强制禁止</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>由于服务类型 TOS，网络不可达</td>
</tr>
<tr>
<td>3</td>
<td>12</td>
<td>由于服务类型 TOS，主机不可达</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>由于过滤，通信被强制禁止</td>
</tr>
<tr>
<td>3</td>
<td>14</td>
<td>主机越权</td>
</tr>
<tr>
<td>3</td>
<td>15</td>
<td>优先中止失效</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>源端被关闭（基本流控制）</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>对网络重定向</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>对主机重定向</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>对服务类型和网络重定向</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>对服务类型和主机重定向</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>回显请求（ping 请求）</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>路由器通告</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>路由器请求</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>传输期间生存时间为 0</td>
</tr>
<tr>
<td>11</td>
<td>1</td>
<td>在数据报组装期间生存时间为 0</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>坏的 IP 首部</td>
</tr>
<tr>
<td>12</td>
<td>1</td>
<td>缺少必需的选项</td>
</tr>
<tr>
<td>13</td>
<td>0</td>
<td>时间戳请求</td>
</tr>
<tr>
<td>14</td>
<td>0</td>
<td>时间戳应答</td>
</tr>
<tr>
<td>17</td>
<td>0</td>
<td>地址掩码请求</td>
</tr>
<tr>
<td>18</td>
<td>0</td>
<td>地址掩码应答</td>
</tr>
</tbody></table>
<h2 id="4-4-传输层"><a href="#4-4-传输层" class="headerlink" title="4.4 传输层"></a>4.4 传输层</h2><h3 id="4-4-1-TCP"><a href="#4-4-1-TCP" class="headerlink" title="4.4.1 TCP"></a>4.4.1 TCP</h3><p>头部：20字节</p>
<ol>
<li><p>源端口：16bit</p>
</li>
<li><p>目的端口:16bit</p>
</li>
<li><p>序列号：32bit</p>
</li>
<li><p>确认号：32bit</p>
</li>
<li><p>偏移字段：4bit</p>
</li>
<li><p>保留字段：4bit</p>
<blockquote>
<p>全为0</p>
</blockquote>
</li>
<li><p>标志位字段</p>
<blockquote>
<ul>
<li>CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。</li>
<li>ECE（ECN Echo）：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。</li>
<li>URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。</li>
<li>ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。</li>
<li>PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。</li>
<li>RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。</li>
<li>SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。</li>
<li>FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。</li>
</ul>
</blockquote>
</li>
<li><p>窗口大小：16bit</p>
</li>
<li><p>TCP校验和：16bit</p>
</li>
<li><p>紧急指针：16bit</p>
</li>
<li><p>可选字段：必须为32bits整数倍</p>
</li>
</ol>
<h3 id="4-4-2-UDP"><a href="#4-4-2-UDP" class="headerlink" title="4.4.2 UDP"></a>4.4.2 UDP</h3><p>全称：User Datagram Protocol (用户数据报协议)</p>
<p>首部：8字节</p>
<ol>
<li>源端口：16bit</li>
<li>目的端口：16bit</li>
<li>长度：16bit</li>
<li>校验值：16bit</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>netwox</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>babun issues</title>
    <url>/jaheel.github.io/2020/02/10/babun-issues/</url>
    <content><![CDATA[<h2 id="1-download"><a href="#1-download" class="headerlink" title="1 download"></a>1 download</h2><p>网址：<a href="http://babun.github.io/">http://babun.github.io/</a></p>
<p>自定义安装路径（cmd中执行）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Babun.bat &#x2F;t c:\Babun</span><br></pre></td></tr></table></figure>



<p>babun启动默认路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">’%userprofile%.Babun\cygwin\home\username’</span><br></pre></td></tr></table></figure>

<h2 id="2-Font-setting"><a href="#2-Font-setting" class="headerlink" title="2 Font setting"></a>2 Font setting</h2><h3 id="2-1-download-fonts"><a href="#2-1-download-fonts" class="headerlink" title="2.1 download fonts"></a>2.1 download fonts</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># clone(克隆git)git clone https:&#x2F;&#x2F;github.com&#x2F;powerline&#x2F;fonts.git --depth&#x3D;1</span><br><span class="line"># install(运行安装脚本)</span><br><span class="line">cd fonts</span><br><span class="line">.&#x2F;install.sh</span><br><span class="line"># clean-up a bit(清楚克隆git文件)_</span><br><span class="line">cd ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure>

<h3 id="2-2-setup-fonts"><a href="#2-2-setup-fonts" class="headerlink" title="2.2 setup fonts"></a>2.2 setup fonts</h3><p>step:</p>
<ol>
<li>在<code>~\.local\share\fonts</code>目录下找到<code>DejaVu Sans Mono for Powerline</code>字体</li>
<li>右击–&gt;安装</li>
</ol>
<a id="more"></a>

<h3 id="2-3-set-babun"><a href="#2-3-set-babun" class="headerlink" title="2.3 set babun"></a>2.3 set babun</h3><p>step:</p>
<ol>
<li><p>打开.minttyrc文件</p>
</li>
<li><p>复制进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BoldAsFont&#x3D;no</span><br><span class="line">Columns&#x3D;150</span><br><span class="line">Rows&#x3D;55</span><br><span class="line">Font&#x3D;DejaVu Sans Mono for Powerline</span><br><span class="line">FontHeight&#x3D;10</span><br><span class="line">Transparency&#x3D;low</span><br><span class="line">ForegroundColour&#x3D;#A0A0A0</span><br><span class="line">BackgroundColour&#x3D;#1B1D1E</span><br><span class="line">CursorColour&#x3D;#A0A0A0</span><br><span class="line">Black&#x3D;#1B1D1E</span><br><span class="line">Red&#x3D;#F92672</span><br><span class="line">Green&#x3D;#82B414</span><br><span class="line">Yellow&#x3D;#FD971F</span><br><span class="line">Blue&#x3D;#268BD2</span><br><span class="line">Magenta&#x3D;#8C54FE</span><br><span class="line">Cyan&#x3D;#56C2D6</span><br><span class="line">White&#x3D;#CCCCC6</span><br><span class="line">BoldRed&#x3D;#FF5995</span><br><span class="line">BoldBlack&#x3D;#505354</span><br><span class="line">BoldGreen&#x3D;#B7EB46</span><br><span class="line">BoldYellow&#x3D;#FEED6C</span><br><span class="line">BoldBlue&#x3D;#62ADE3</span><br><span class="line">BoldMagenta&#x3D;#BFA0FE</span><br><span class="line">BoldCyan&#x3D;#94D8E5</span><br><span class="line">BoldWhite&#x3D;#F8F8F2</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-5-restart-babun"><a href="#2-5-restart-babun" class="headerlink" title="2.5 restart babun"></a>2.5 restart babun</h3><h2 id="3-Python配置"><a href="#3-Python配置" class="headerlink" title="3 Python配置"></a>3 Python配置</h2><p>Babun默认Python是python2</p>
<p>step:</p>
<ol>
<li>删除babun与python的连接</li>
<li>绑定自己系统中Python所在文件夹创建python连接</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;bin</span><br><span class="line">rm -rf python #解除原版绑定</span><br><span class="line">ln -s &#x2F;cygdrive&#x2F;d&#x2F;...&#x2F;python.exe &#x2F;usr&#x2F;bin&#x2F;python #绑定python路径</span><br><span class="line">python -i #在Babun中，需要加上-i参数，才能正常启动python</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>babun</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>babun</tag>
      </tags>
  </entry>
  <entry>
    <title>babun常用命令</title>
    <url>/jaheel.github.io/2020/10/19/babun%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pact install # 安装软件包</span><br><span class="line">pact remove # 删除指定的软件包</span><br><span class="line">pact update # 更新指定的软件包</span><br><span class="line">pact show # 显示已安装的软件包</span><br><span class="line">pact find # 搜索软件包</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>babun</category>
      </categories>
      <tags>
        <tag>babun</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code 快捷键</title>
    <url>/jaheel.github.io/2020/10/19/VS%20Code%20%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="快捷键组合方式"><a href="#快捷键组合方式" class="headerlink" title="快捷键组合方式"></a>快捷键组合方式</h2><ol>
<li>Ctrl + Shift + ?</li>
<li>Ctrl+C Ctrl+V</li>
<li>Ctrl+Click </li>
</ol>
<h2 id="通用快捷键"><a href="#通用快捷键" class="headerlink" title="通用快捷键"></a>通用快捷键</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+Shift+P</td>
<td>展示全局命令面板</td>
</tr>
<tr>
<td>Ctrl+P</td>
<td>快速打开最近打开的文件</td>
</tr>
<tr>
<td>Ctrl+Shift+N</td>
<td>打开新的编辑器窗口</td>
</tr>
<tr>
<td>Ctrl+Shift+W</td>
<td>关闭编辑器</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="基础编辑"><a href="#基础编辑" class="headerlink" title="基础编辑"></a>基础编辑</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+X</td>
<td>剪切</td>
</tr>
<tr>
<td>Ctrl+C</td>
<td>复制</td>
</tr>
<tr>
<td>Alt+up/down</td>
<td>移动行上下</td>
</tr>
<tr>
<td>Shift+Alt + up/down</td>
<td>在当前行上下复制当前行</td>
</tr>
<tr>
<td>Ctrl + Shift + K</td>
<td>删除行</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>在当前行下插入新的一行</td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>在当前行上插入新的一行</td>
</tr>
<tr>
<td>Ctrl + Shift + |</td>
<td>匹配花括号的闭合处，跳转</td>
</tr>
<tr>
<td>Home</td>
<td>光标跳转到行头</td>
</tr>
<tr>
<td>End</td>
<td>光标跳转到行尾</td>
</tr>
<tr>
<td>Ctrl + Home</td>
<td>跳转到页头</td>
</tr>
<tr>
<td>Ctrl + End</td>
<td>跳转到页尾</td>
</tr>
<tr>
<td>Ctrl + up/down</td>
<td>行视图上下偏移</td>
</tr>
<tr>
<td>Alt + PgUp/PgDown</td>
<td>屏视图上下偏移</td>
</tr>
<tr>
<td>Ctrl + Shift + [</td>
<td>折叠区域代码</td>
</tr>
<tr>
<td>Ctrl + Shift + ]</td>
<td>展开区域代码</td>
</tr>
<tr>
<td>Ctrl + K + C</td>
<td>添加行注释</td>
</tr>
<tr>
<td>Ctrl + K + U</td>
<td>删除行注释</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>添加关闭行注释</td>
</tr>
<tr>
<td>Shift + Alt + A</td>
<td>块区域注释</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>列出所有符号</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>跳转行</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>跳转文件</td>
</tr>
<tr>
<td>Ctrl + Shift + O</td>
<td>跳转到符号处</td>
</tr>
<tr>
<td>F8</td>
<td>跳转到下一个错误或者警告</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>跳转到上一个错误或者警告</td>
</tr>
<tr>
<td>Ctrl + Shift +Tab</td>
<td>切换到最近打开的文件</td>
</tr>
<tr>
<td>Ctrl + Shift + M</td>
<td>打开问题展示面板</td>
</tr>
<tr>
<td>Alt + left/right</td>
<td>向后、向前</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>进入用Tab来移动焦点</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="查询与替换"><a href="#查询与替换" class="headerlink" title="查询与替换"></a>查询与替换</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + F</td>
<td>查询</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>替换</td>
</tr>
<tr>
<td>F3 / Shift + F3</td>
<td>查询下一个/上一个</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>选中所有出现在查询中的</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="语言操作"><a href="#语言操作" class="headerlink" title="语言操作"></a>语言操作</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>F12</td>
<td>跳转到定义处</td>
</tr>
<tr>
<td>Alt + F12</td>
<td>代码片段显示定义</td>
</tr>
<tr>
<td>Shift + F12</td>
<td>显示所有引用</td>
</tr>
<tr>
<td>F2</td>
<td>重命名符号</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + N</td>
<td>新建文件</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>打开文件</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>保存文件</td>
</tr>
<tr>
<td>Ctrl + Shift + S</td>
<td>另存为</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>VS Code</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>git command</title>
    <url>/jaheel.github.io/2020/10/19/git-command-learning/</url>
    <content><![CDATA[<h3 id="创建与合并命令"><a href="#创建与合并命令" class="headerlink" title="创建与合并命令"></a>创建与合并命令</h3><p>查看分支：git branch</p>
<p>创建分支：git branch name</p>
<p>切换分支：git checkout name</p>
<p>创建+切换分支：git checkout -b name</p>
<p>合并某分支到当前分支：git merge name</p>
<p>删除分支：git branch -d name</p>
<h3 id="git-basic-command"><a href="#git-basic-command" class="headerlink" title="git basic command"></a>git basic command</h3><p>　   mkdir：         XX (创建一个空目录 XX指目录名)</p>
<p>　　pwd：          显示当前目录的路径。</p>
<p>　　git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</p>
<p>　　git add XX       把xx文件添加到暂存区去。</p>
<p>　　git commit –m “XX”  提交文件 –m 后面的是注释。</p>
<a id="more"></a>

<p>　　git status        查看仓库状态</p>
<p>　　git diff  XX      查看XX文件修改了那些内容</p>
<p>　　git log          查看历史记录</p>
<p>　　git reset  –hard HEAD^ 或者 git reset  –hard HEAD~ 回退到上一个版本</p>
<p>　　(如果想回退到100个版本，使用git reset –hard HEAD~100 )</p>
<p>　　cat XX         查看XX文件内容</p>
<p>　　git reflog       查看历史记录的版本号id</p>
<p>　　git checkout – XX  把XX文件在工作区的修改全部撤销。</p>
<p>　　git rm XX          删除XX文件</p>
<p>　　git remote add origin <a href="https://github.com/tugenhua0707/testgit">https://github.com/tugenhua0707/testgit</a> 关联一个远程库</p>
<p>　　git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库</p>
<p>　　git clone <a href="https://github.com/tugenhua0707/testgit">https://github.com/tugenhua0707/testgit</a>  从远程库中克隆</p>
<p>　　git checkout –b dev  创建dev分支 并切换到dev分支上</p>
<p>　　git branch  查看当前所有的分支</p>
<p>　　git checkout master 切换回master分支</p>
<p>　　git merge dev    在当前的分支上合并dev分支</p>
<p>　　git branch –d dev 删除dev分支</p>
<p>　　git branch name  创建分支</p>
<p>　　git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作</p>
<p>　　git stash list 查看所有被隐藏的文件列表</p>
<p>　　git stash apply 恢复被隐藏的文件，但是内容不删除</p>
<p>　　git stash drop 删除文件</p>
<p>　　git stash pop 恢复文件的同时 也删除文件</p>
<p>　　git remote 查看远程库的信息</p>
<p>　　git remote –v 查看远程库的详细信息</p>
<p>　　git push origin master  Git会把master分支推送到远程库对应的远程分支上</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-op</title>
    <url>/jaheel.github.io/2020/10/19/hexo-op/</url>
    <content><![CDATA[<h1 id="hexo-op"><a href="#hexo-op" class="headerlink" title="hexo op"></a>hexo op</h1><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<a id="more"></a>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>babun</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-建站总结</title>
    <url>/jaheel.github.io/2020/10/19/hexo-%E5%BB%BA%E7%AB%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="搭站"><a href="#搭站" class="headerlink" title="搭站"></a>搭站</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h2><p>OS : win 10 x64 教育版</p>
<p>Cmd: git bash</p>
<p>Architecture: Hexo</p>
<h2 id="2-准备工具"><a href="#2-准备工具" class="headerlink" title="2 准备工具"></a>2 准备工具</h2><h3 id="2-1-git"><a href="#2-1-git" class="headerlink" title="2.1 git"></a>2.1 git</h3><p>下载网址： <a href="http://git-scm.com/download/win">http://git-scm.com/download/win</a></p>
<h3 id="2-2-Node-js"><a href="#2-2-Node-js" class="headerlink" title="2.2 Node.js"></a>2.2 Node.js</h3><p>下载网址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></p>
<p>包含：node、npm</p>
<a id="more"></a>

<h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3 安装hexo"></a>3 安装hexo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">hexo -v</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-配置站点"><a href="#4-配置站点" class="headerlink" title="4 配置站点"></a>4 配置站点</h2><p>step 1: 建立站点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建站</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="comment"># 进入blog文件夹</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># npm配置</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>step 2: 配置站点信息</p>
<p>​    打开<strong>_config.yml</strong>文件，修改配置信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site </span></span><br><span class="line">title: <span class="comment">#填站点名称</span></span><br><span class="line">subtitle: <span class="comment"># 小标题</span></span><br><span class="line">description:</span><br><span class="line">author:</span><br><span class="line">language: <span class="comment"># en(英语)</span></span><br><span class="line">timezone: <span class="comment"># 时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line">url:https://jaheel.github.io/blog</span><br><span class="line">root:/jaheel.github.io/ <span class="comment">#仓库名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-安装主题"><a href="#5-安装主题" class="headerlink" title="5 安装主题"></a>5 安装主题</h2><p>选择了<strong>Next</strong>主题，克隆到themes/next文件夹中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>修改<strong>_config.yml</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">theme: <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="6-生成与部署"><a href="#6-生成与部署" class="headerlink" title="6 生成与部署"></a>6 生成与部署</h2><h3 id="6-1-生成"><a href="#6-1-生成" class="headerlink" title="6.1 生成"></a>6.1 生成</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g <span class="comment"># 自动生成</span></span><br><span class="line">hexo s <span class="comment"># 本地测试</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-部署"><a href="#6-2-部署" class="headerlink" title="6.2 部署"></a>6.2 部署</h3><p><strong>_config.yml</strong>文件末尾添加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	<span class="built_in">type</span>: git</span><br><span class="line">	repo: git@github.com:jaheel/jaheel.github.io.git <span class="comment">#SSH方式，避免HTTPS方式多次输入用户名、密码</span></span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>

<p>部署到git:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 未安装git部署依赖包，需输入以下命令下载</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<p>部署成功后即可输入 <strong>xxxx.github.io</strong> 网址进行联网预览</p>
<h2 id="7-绑定域名"><a href="#7-绑定域名" class="headerlink" title="7 绑定域名"></a>7 绑定域名</h2><p>域名代理厂商：阿里云万网（其他代理商同理）</p>
<p>step 1: </p>
<p>​        购买想要的域名后，在<strong>域名管理控制台</strong>找到个性化域名，添加解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记录类型：CNAME</span><br><span class="line">主机记录：www</span><br><span class="line">记录值： xxxx.github.io</span><br><span class="line">解析线路：default</span><br><span class="line"></span><br><span class="line">记录类型：A</span><br><span class="line">主机记录：@</span><br><span class="line">记录值：xxxx.github.io对应的IPv4地址</span><br><span class="line">解析线路：default</span><br></pre></td></tr></table></figure>



<p>step 2:</p>
<p>​        回到github仓库，进入setting，设置Custom domain，输入域名，点击Save保存</p>
<p>step 3:</p>
<p>​        进入本地blog/source目录下，创建记事本，输入域名，保存，命名为CNAME所有文件（无后缀）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>打开浏览器在地址栏输入域名即可访问</p>
<h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><h2 id="1-标签"><a href="#1-标签" class="headerlink" title="1 标签"></a>1 标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>进入新增的tags文件夹，用VSCode打开，修改头部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: xxx</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false # 最好禁了</span><br></pre></td></tr></table></figure>



<p>然后就在各个加入的文件中加入头部就行，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签测试文章</span><br><span class="line">tags:</span><br><span class="line">  - Testing</span><br><span class="line">  - Another Tag</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>其余操作同标签</p>
<h1 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h1><p>官网：<a href="https://theme-next.iissnan.com/theme-settings.html#fonts-customization">https://theme-next.iissnan.com/theme-settings.html#fonts-customization</a></p>
<h1 id="sitemap配置"><a href="#sitemap配置" class="headerlink" title="sitemap配置"></a>sitemap配置</h1><p>教程网址：<a href="http://lindaxiao-hust.github.io/2016/04/06/hexo-next-sitemap/">http://lindaxiao-hust.github.io/2016/04/06/hexo-next-sitemap/</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-博客迁移</title>
    <url>/jaheel.github.io/2020/10/19/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h2><p>将原来电脑已经配置好并生成的Hexo目录拷贝到新电脑。</p>
<p>只需拷贝以下目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds&#x2F;</span><br><span class="line">source&#x2F;</span><br><span class="line">themes&#x2F;</span><br></pre></td></tr></table></figure>

<p>放到同一目录下。如：hexo/</p>
<h2 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h2><p>配置node.js</p>
<p>参考：Hexo-建站</p>
<h2 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h2><p>安装hexo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<h2 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h2><p>进入hexo/目录</p>
<p>安装模块:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<h2 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h2><p>部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>串（堆分配）</title>
    <url>/jaheel.github.io/2020/10/19/%E4%B8%B2%EF%BC%88%E5%A0%86%E5%88%86%E9%85%8D%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>页码：P75-77</p>
<p>IDE：VS2015</p>
<p>实现：堆分配的各种基本操作</p>
<a id="more"></a>



<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ch;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">StrInsert</span><span class="params">(HString &amp;S, <span class="keyword">int</span> pos, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;S.length + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (T.length)</span><br><span class="line">	&#123;</span><br><span class="line">		S.ch = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(S.ch, (S.length + T.length) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = S.length - <span class="number">1</span>; i &gt;= pos - <span class="number">1</span>; --i)</span><br><span class="line">			S.ch[i + T.length] = S.ch[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++)</span><br><span class="line">			S.ch[pos - <span class="number">1</span> + i] = T.ch[i];</span><br><span class="line">		S.length += T.length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(HString &amp;T, <span class="keyword">char</span> *chars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> *c = chars;</span><br><span class="line">	<span class="keyword">if</span> (T.ch)</span><br><span class="line">		<span class="built_in">free</span>(T.ch);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; *c; ++i, ++c);</span><br><span class="line">	<span class="keyword">if</span> (!i)</span><br><span class="line">	&#123;</span><br><span class="line">		T.ch = <span class="literal">NULL</span>;</span><br><span class="line">		T.length = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(T.ch = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(i * <span class="keyword">sizeof</span>(<span class="keyword">char</span>))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			T.ch[j] = chars[j];</span><br><span class="line">		&#125;</span><br><span class="line">		T.length = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(HString S, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length&amp;&amp;i &lt; T.length; ++i)</span><br><span class="line">		<span class="keyword">if</span> (S.ch[i] != T.ch[i])</span><br><span class="line">			<span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">	<span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">ClearString</span><span class="params">(HString &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.ch)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(S.ch);</span><br><span class="line">		S.ch = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	S.length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(HString &amp;T, HString S1, HString S2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T.ch)</span><br><span class="line">		<span class="built_in">free</span>(T.ch);</span><br><span class="line">	T.ch = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((S1.length + S2.length) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S1.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		T.ch[i] = S1.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	T.length = S1.length + S2.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S2.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		T.ch[S1.length + i] = S2.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">SubString</span><span class="params">(HString &amp;Sub, HString S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;S.length || len&lt;<span class="number">0</span> || len&gt;S.length - pos + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (Sub.ch)</span><br><span class="line">		<span class="built_in">free</span>(Sub.ch);</span><br><span class="line">	<span class="keyword">if</span> (!len)</span><br><span class="line">	&#123;</span><br><span class="line">		Sub.ch = <span class="literal">NULL</span>;</span><br><span class="line">		Sub.length = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Sub.ch = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Sub.ch[i] = S.ch[pos - <span class="number">1</span> + i];</span><br><span class="line">		&#125;</span><br><span class="line">		Sub.length = len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispStr</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (S.length &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; S.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; S.ch[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">StrCopy</span><span class="params">(HString &amp;S, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.ch)</span><br><span class="line">		<span class="built_in">free</span>(S.ch);</span><br><span class="line"> </span><br><span class="line">	S.ch = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((T.length) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		S.ch[i] = T.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	S.length = T.length;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">StrDelete</span><span class="params">(HString &amp;S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;S.length || len&lt;<span class="number">0</span> || len&gt;S.length - pos + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		S.ch[pos - <span class="number">1</span> + i] = S.ch[pos - <span class="number">1</span> + len + i];</span><br><span class="line">	&#125;</span><br><span class="line">	S.length -= len;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HString T, S, S1, S2, Sub;</span><br><span class="line">	<span class="keyword">int</span> pos, len;</span><br><span class="line">	<span class="keyword">char</span> *a, str[<span class="number">100</span>], *chars = <span class="string">&quot;House&quot;</span>;</span><br><span class="line">	T.ch = <span class="literal">NULL</span>;</span><br><span class="line">	S.ch = <span class="literal">NULL</span>;</span><br><span class="line">	S1.ch = <span class="literal">NULL</span>;</span><br><span class="line">	S2.ch = <span class="literal">NULL</span>;</span><br><span class="line">	Sub.ch = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出字符串常量chars:&quot;</span> &lt;&lt; chars &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	StrAssign(T, chars);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;生成一个其值等于串常量chars的串T：&quot;</span>;</span><br><span class="line">	DispStr(T);</span><br><span class="line">	StrCopy(S, T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;将串T的值复制到串S中，串S的值为：&quot;</span>;</span><br><span class="line">	DispStr(S);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;串S的长度为：&quot;</span> &lt;&lt; StrLength(S) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;比较串S和串T的大小：&quot;</span> &lt;&lt; StrCompare(S, T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;将S清为空串！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ClearString(S);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;串S的值为：&quot;</span>;</span><br><span class="line">	DispStr(S);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;串T的值为：&quot;</span>;</span><br><span class="line">	DispStr(T);</span><br><span class="line">	a = str;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S1：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	StrAssign(S1, a);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;串S1的值为：&quot;</span>;</span><br><span class="line">	DispStr(S1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S2：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	StrAssign(S2, a);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;串S2的值为：&quot;</span>;</span><br><span class="line">	DispStr(S2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;返回由S1和S2联接而成的新串S：&quot;</span>;</span><br><span class="line">	Concat(S, S1, S2);</span><br><span class="line">	DispStr(S);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入S的子串的起始字符位置：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pos;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入S的子串的长度&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;用Sub返回串S的第&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;个字符起长度为&quot;</span> &lt;&lt; len &lt;&lt; <span class="string">&quot;的子串：&quot;</span>;</span><br><span class="line">	SubString(Sub, S, pos, len);</span><br><span class="line">	DispStr(Sub);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S的插入位置:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pos;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;在串S的第&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;个位置插入串T，插入后串S的值为：&quot;</span>;</span><br><span class="line">	StrInsert(S, pos, T);</span><br><span class="line">	DispStr(S);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S删除的子串的起始字符位置：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pos;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S删除的子串的长度：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;串S中删除第&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;个字符起长度为&quot;</span> &lt;&lt; len &lt;&lt; <span class="string">&quot;的子串，删除后S的值为：&quot;</span>;</span><br><span class="line">	StrDelete(S, pos, len);</span><br><span class="line">	DispStr(S);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>串（定长）</title>
    <url>/jaheel.github.io/2020/10/19/%E4%B8%B2%EF%BC%88%E5%AE%9A%E9%95%BF%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>页码：P73</p>
<p>IDE：VS2015</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SString[MAXSTRLEN + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString &amp;T, SString S1, SString S2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> uncut;</span><br><span class="line">	<span class="keyword">if</span> (S1[<span class="number">0</span>] +S2[<span class="number">0</span>] &lt;= MAXSTRLEN)<span class="comment">//未被截断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			T[i] = S1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S2[<span class="number">0</span>]; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			T[i + S1[<span class="number">0</span>]] = S2[i];</span><br><span class="line">		&#125;</span><br><span class="line">		T[<span class="number">0</span>] = S1[<span class="number">0</span>] + S2[<span class="number">0</span>];</span><br><span class="line">		uncut = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S1[<span class="number">0</span>] &lt; MAXSTRLEN)<span class="comment">//截断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)S1[<span class="number">0</span>]; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			T[i] = S1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAXSTRLEN - (<span class="keyword">int</span>)S1[<span class="number">0</span>]; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			T[i + S1[<span class="number">0</span>]] = S2[i];</span><br><span class="line">		&#125;</span><br><span class="line">		T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">		uncut = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//截取，只取S1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAXSTRLEN; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			T[i] = S1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		uncut = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> uncut;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;(<span class="keyword">int</span>)S[<span class="number">0</span>] || len&lt;<span class="number">0</span> || len&gt;(<span class="keyword">int</span>)S[<span class="number">0</span>] - pos + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sub[i] = S[pos + i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	Sub[<span class="number">0</span>] = len;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SString T, S1, S2, S, Sub;</span><br><span class="line">	<span class="keyword">int</span> i, pos, len;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S1的长度：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; S1[<span class="number">0</span>];</span><br><span class="line">	S1[<span class="number">0</span>] -= <span class="number">48</span>;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S1的值：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; S1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输出串S1的值：&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; S1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S2的长度：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; S2[<span class="number">0</span>];</span><br><span class="line">	S2[<span class="number">0</span>] -= <span class="number">48</span>;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S2的值：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S2[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; S2[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输出串S2的值：&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S2[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; S2[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Concat(T, S1, S2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出串S1和串S2的联接串T的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S的长度：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; S[<span class="number">0</span>];</span><br><span class="line">	S[<span class="number">0</span>] -= <span class="number">48</span>;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; S[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出串S的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; S[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S的子串Sub的开始字符位置：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pos;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入串S的子串Sub的长度：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">	SubString(Sub, S, pos, len);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出子串Sub的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Sub[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Sub[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树（创建、遍历）&lt;递归、非递归&gt;</title>
    <url>/jaheel.github.io/2020/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%88%9B%E5%BB%BA%E3%80%81%E9%81%8D%E5%8E%86%EF%BC%89%E9%80%92%E5%BD%92%E3%80%81%E9%9D%9E%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>表示形式：链式结构</p>
<p>代码如下：</p>
<a id="more"></a>

<p>递归算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Nodenum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		T-&gt;data = ch;</span><br><span class="line">		CreateBiTree(T-&gt;lchild);</span><br><span class="line">		CreateBiTree(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">		<span class="keyword">if</span> (PreOrderTraverse(T-&gt;lchild))</span><br><span class="line">			<span class="keyword">if</span> (PreOrderTraverse(T-&gt;rchild))</span><br><span class="line">				<span class="keyword">return</span> OK;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (InOrderTraverse(T-&gt;lchild))</span><br><span class="line">			m = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">		<span class="keyword">if</span> (m)</span><br><span class="line">			<span class="keyword">if</span> (InOrderTraverse(T-&gt;rchild))</span><br><span class="line">				<span class="keyword">return</span> OK;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (PostOrderTraverse(T-&gt;lchild))</span><br><span class="line">			<span class="keyword">if</span> (PostOrderTraverse(T-&gt;rchild))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">				<span class="keyword">return</span> OK;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		Nodenum++;</span><br><span class="line">		<span class="keyword">if</span> (NodeCount(T-&gt;lchild))</span><br><span class="line">			<span class="keyword">if</span> (NodeCount(T-&gt;rchild))</span><br><span class="line">				<span class="keyword">return</span> OK;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span>&amp;&amp;T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">			Count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (LeafCount(T-&gt;lchild))</span><br><span class="line">			<span class="keyword">if</span> (LeafCount(T-&gt;rchild))</span><br><span class="line">				<span class="keyword">return</span> OK;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">交换二叉树中所有节点的左右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">ExchangeBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree p;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild || T-&gt;rchild) &#123;</span><br><span class="line">			p = T-&gt;lchild;</span><br><span class="line">			T-&gt;lchild = T-&gt;rchild;</span><br><span class="line">			T-&gt;rchild = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ExchangeBiTree(T-&gt;lchild))</span><br><span class="line">			<span class="keyword">if</span> (ExchangeBiTree(T-&gt;rchild))</span><br><span class="line">				<span class="keyword">return</span> OK;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CopyBiTree</span><span class="params">(BiTree T, BiTree &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		B = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(B = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		B-&gt;data = T-&gt;data;</span><br><span class="line">		CopyBiTree(T-&gt;lchild, B-&gt;lchild);</span><br><span class="line">		CopyBiTree(T-&gt;rchild, B-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">DestroyTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		DestroyTree(T-&gt;lchild);</span><br><span class="line">		DestroyTree(T-&gt;rchild);</span><br><span class="line">		<span class="built_in">free</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">ClearTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		T = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> leftDepth, rightDepth;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		leftDepth = Depth(T-&gt;lchild);</span><br><span class="line">		rightDepth = Depth(T-&gt;rchild);</span><br><span class="line">		<span class="keyword">if</span> (leftDepth &gt;= rightDepth)</span><br><span class="line">			<span class="keyword">return</span> leftDepth + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> rightDepth + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree T, B;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;创建二叉树，按先序次序输入二叉树中结点的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	CreateBiTree(T);</span><br><span class="line">	NodeCount(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二叉树的结点个数为&quot;</span> &lt;&lt; Nodenum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二叉树的深度为：&quot;</span> &lt;&lt; Depth(T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历二叉树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PreOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历二叉树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历二叉树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PostOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出二叉树的叶子结点：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	LeafCount(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;统计二叉树的叶子结点个数：&quot;</span> &lt;&lt; Count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换二叉树中所有节点的左右子树！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ExchangeBiTree(T);</span><br><span class="line">	<span class="keyword">if</span> (CopyBiTree(T, B) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功复制二叉树T到二叉树B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (DestroyTree(T) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功销毁二叉树T！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (ClearTree(T) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功将二叉树T置为空树！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历二叉树B，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PreOrderTraverse(B);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历二叉树B，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(B);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历二叉树B，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PostOrderTraverse(B);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 50</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Nodenum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;<span class="comment">//二叉树叶子结点统计</span></span><br><span class="line"> </span><br><span class="line"><span class="function">BiTree <span class="title">CreateBiTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TElemType ch[maxSize];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">int</span> len = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(ch);</span><br><span class="line">	BiTree <span class="built_in">stack</span>[maxSize];</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ch[i] == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	BiTree temp;</span><br><span class="line">	BiTree root = <span class="keyword">new</span> BiTNode();</span><br><span class="line">	root-&gt;data = ch[i];</span><br><span class="line">	root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">stack</span>[++top] = root;<span class="comment">//根节点入栈</span></span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;<span class="comment">//标志位：第一种情况：创建左孩子；2：创建右孩子；3：左右孩子均创建，出栈</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; len)</span><br><span class="line">	&#123;</span><br><span class="line">		BiTree pNew = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//创建左孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			&#x27;#&#x27;说明这是栈顶结点无左孩子，把标志位置2，判断右孩子</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span> (ch[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				flag = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				pNew = <span class="keyword">new</span> BiTNode();</span><br><span class="line">				pNew-&gt;data = ch[i];</span><br><span class="line">				pNew-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">				pNew-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">				temp = <span class="built_in">stack</span>[top];<span class="comment">//取出当前栈顶</span></span><br><span class="line">				temp-&gt;lchild = pNew;<span class="comment">//当前结点为栈顶结点的左孩子</span></span><br><span class="line">				<span class="built_in">stack</span>[++top] = pNew;<span class="comment">//当前结点入栈</span></span><br><span class="line">				flag = <span class="number">1</span>;<span class="comment">//使标志位初始化</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>)<span class="comment">//创建右孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			栈顶结点无右孩子</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span> (ch[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				flag = <span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				与创建左孩子同理</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				pNew = <span class="keyword">new</span> BiTNode();</span><br><span class="line">				pNew-&gt;data = ch[i];</span><br><span class="line">				pNew-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">				pNew-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">				temp = <span class="built_in">stack</span>[top];</span><br><span class="line">				temp-&gt;rchild = pNew;</span><br><span class="line">				<span class="built_in">stack</span>[++top] = pNew;</span><br><span class="line">				flag = <span class="number">1</span>;<span class="comment">//置1继续判断结点的左孩子（左孩子优先）</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//左右孩子都创建</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp = <span class="built_in">stack</span>[top--];</span><br><span class="line">			<span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">stack</span>[top]-&gt;rchild == temp)</span><br><span class="line">				--top;</span><br><span class="line"> </span><br><span class="line">			flag = <span class="number">2</span>;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先序遍历非递归算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		BiTNode *Stack[maxSize];</span><br><span class="line">		<span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">		BiTNode *p;</span><br><span class="line">		Stack[++top] = T;</span><br><span class="line">		<span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p = Stack[top--];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">				Stack[++top] = p-&gt;rchild;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">				Stack[++top] = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中序遍历的非递归算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		BiTNode *Stack[maxSize];</span><br><span class="line">		<span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">		BiTNode *p = T;</span><br><span class="line">		<span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Stack[++top] = p;</span><br><span class="line">				p = p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (top != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p = Stack[top--];</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">				p = p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后序遍历的非递归算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		BiTNode *Stack1[maxSize];</span><br><span class="line">		<span class="keyword">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">		BiTNode *Stack2[maxSize];</span><br><span class="line">		<span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">		BiTNode *p = <span class="literal">NULL</span>;</span><br><span class="line">		Stack1[++top1] = T;</span><br><span class="line">		<span class="keyword">while</span> (top1 != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p = Stack1[top1--];</span><br><span class="line">			Stack2[++top2] = p;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">				Stack1[++top1] = p-&gt;lchild;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">				Stack1[++top1] = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (top2 != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p = Stack2[top2--];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">层次遍历非递归算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> front, rear;</span><br><span class="line">	BiTNode *<span class="built_in">queue</span>[maxSize];<span class="comment">//队列先进先出</span></span><br><span class="line">	front = rear = <span class="number">0</span>;</span><br><span class="line">	BiTNode *q;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rear = (rear + <span class="number">1</span>) % maxSize;<span class="comment">//循环队列，避免越界</span></span><br><span class="line">		<span class="built_in">queue</span>[rear] = T;<span class="comment">//首节点结点插入队尾</span></span><br><span class="line">		<span class="keyword">while</span> (front != rear)<span class="comment">//说明队列中尚有结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			front = (front + <span class="number">1</span>) % maxSize;<span class="comment">//避免越界</span></span><br><span class="line">			q = <span class="built_in">queue</span>[front];<span class="comment">//队头结点出队</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; q-&gt;data;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			判断左右孩子，左孩子先进队列</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				<span class="built_in">queue</span>[rear] = q-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				<span class="built_in">queue</span>[rear] = q-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		Nodenum++;</span><br><span class="line">		<span class="keyword">if</span> (NodeCount(T-&gt;lchild))</span><br><span class="line">			<span class="keyword">if</span> (NodeCount(T-&gt;rchild))</span><br><span class="line">				<span class="keyword">return</span> OK;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   原理和层次遍历相同，稍作修改加个判断条件：</span></span><br><span class="line"><span class="comment">       此结点左右孩子是否为空，是则输出，不是则判断下一个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> front, rear;</span><br><span class="line">	BiTNode *<span class="built_in">queue</span>[maxSize];<span class="comment">//队列先进先出</span></span><br><span class="line">	front = rear = <span class="number">0</span>;</span><br><span class="line">	BiTNode *q;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rear = (rear + <span class="number">1</span>) % maxSize;<span class="comment">//循环队列，避免越界</span></span><br><span class="line">		<span class="built_in">queue</span>[rear] = T;<span class="comment">//首节点结点插入队尾</span></span><br><span class="line">		<span class="keyword">while</span> (front != rear)<span class="comment">//说明队列中尚有结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			front = (front + <span class="number">1</span>) % maxSize;<span class="comment">//避免越界</span></span><br><span class="line">			q = <span class="built_in">queue</span>[front];<span class="comment">//队头结点出队</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			判断左右孩子，左孩子先进队列</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				<span class="built_in">queue</span>[rear] = q-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				<span class="built_in">queue</span>[rear] = q-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>&amp;&amp;q-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; q-&gt;data;</span><br><span class="line">				Count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">交换二叉树中所有节点的左右子树:</span></span><br><span class="line"><span class="comment">(非递归）</span></span><br><span class="line"><span class="comment">     第一步：层次遍历：入队列</span></span><br><span class="line"><span class="comment">	 第二步：交换每个结点的左右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExchangeBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		BiTNode *temp;</span><br><span class="line">		BiTNode *p;</span><br><span class="line">		<span class="keyword">int</span> front, rear;</span><br><span class="line">		front = rear = <span class="number">0</span>;</span><br><span class="line">		BiTNode *<span class="built_in">queue</span>[maxSize];</span><br><span class="line">		<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			rear = (rear + <span class="number">1</span>) % maxSize;<span class="comment">//循环队列，避免越界</span></span><br><span class="line">			<span class="built_in">queue</span>[rear] = T;<span class="comment">//首节点结点插入队尾</span></span><br><span class="line">			<span class="keyword">while</span> (front != rear)<span class="comment">//说明队列中尚有结点</span></span><br><span class="line">			&#123;</span><br><span class="line">				front = (front + <span class="number">1</span>) % maxSize;<span class="comment">//避免越界</span></span><br><span class="line">				p = <span class="built_in">queue</span>[front];<span class="comment">//队头结点出队</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				判断左右孩子，左右孩子进队列</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">					<span class="built_in">queue</span>[rear] = p-&gt;lchild;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">					<span class="built_in">queue</span>[rear] = p-&gt;rchild;</span><br><span class="line">				&#125;</span><br><span class="line"> </span><br><span class="line">				temp = p-&gt;lchild;</span><br><span class="line">				p-&gt;lchild = p-&gt;rchild;</span><br><span class="line">				p-&gt;rchild = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CopyBiTree</span><span class="params">(BiTree T, BiTree &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		B = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(B = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		B-&gt;data = T-&gt;data;</span><br><span class="line">		CopyBiTree(T-&gt;lchild, B-&gt;lchild);</span><br><span class="line">		CopyBiTree(T-&gt;rchild, B-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    销毁二叉树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		DestroyTree(T-&gt;lchild);</span><br><span class="line">		DestroyTree(T-&gt;rchild);</span><br><span class="line">		<span class="built_in">free</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   清空二叉树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">ClearTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		T = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   求二叉树的深度(非递归算法）：（层次遍历）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> level = <span class="number">0</span>;<span class="comment">//层次</span></span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">	BiTNode *Queue[maxSize]; </span><br><span class="line">	Queue[rear++] = T;</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">while</span> (front!=rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = rear - front;</span><br><span class="line">		level++;</span><br><span class="line">		<span class="keyword">while</span> (len--)</span><br><span class="line">		&#123;</span><br><span class="line">			BiTNode *temp = Queue[front];</span><br><span class="line">			front++;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;lchild)</span><br><span class="line">				Queue[rear++] = temp-&gt;lchild;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;rchild)</span><br><span class="line">				Queue[rear++] = temp-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;					</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree T, B;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;创建二叉树，按先序次序输入二叉树中结点的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	T=CreateBiTree();</span><br><span class="line">	NodeCount(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二叉树的结点个数为&quot;</span> &lt;&lt; Nodenum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二叉树的深度为：&quot;</span> &lt;&lt; Depth(T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历二叉树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PreOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历二叉树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历二叉树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PostOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;层次遍历二叉树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	level(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出二叉树的叶子结点：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	LeafCount(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;统计二叉树的叶子结点个数：&quot;</span> &lt;&lt; Count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换二叉树中所有节点的左右子树！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ExchangeBiTree(T);</span><br><span class="line">	<span class="keyword">if</span> (CopyBiTree(T, B) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功复制二叉树T到二叉树B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (DestroyTree(T) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功销毁二叉树T！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (ClearTree(T) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功将二叉树T置为空树！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历二叉树B，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PreOrderTraverse(B);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历二叉树B，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(B);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历二叉树B，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PostOrderTraverse(B);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>体系结构设计</title>
    <url>/jaheel.github.io/2020/10/19/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="1-决策"><a href="#1-决策" class="headerlink" title="1 决策"></a>1 决策</h1><p>功能性需求：基于特定的体系结构模式或风格</p>
<p>非功能性需求：性能、信息安全性(security)、安全性(safety)、可用性、可维护性</p>
<h1 id="2-体系结构视图"><a href="#2-体系结构视图" class="headerlink" title="2 体系结构视图"></a>2 体系结构视图</h1><ol>
<li><p>逻辑视图</p>
<blockquote>
<p>显示系统中对象和对象类的一些主要抽象</p>
</blockquote>
</li>
<li><p>进程视图</p>
<blockquote>
<p>显示在运行时系统是如何组织为一组交互的进程</p>
<ul>
<li>对非功能系统特征的判断有效</li>
</ul>
</blockquote>
</li>
<li><p>开发视图</p>
<blockquote>
<p>将软件分解成可以由单独的开发人员或开发团队实现的组件</p>
<ul>
<li>软件的管理者、程序员</li>
</ul>
</blockquote>
</li>
<li><p>物理视图</p>
<blockquote>
<p>显示系统硬件和系统中软件组件是如何分布在处理器上的。</p>
<ul>
<li>系统工程师</li>
</ul>
</blockquote>
</li>
</ol>
<h1 id="3-体系结构模式"><a href="#3-体系结构模式" class="headerlink" title="3 体系结构模式"></a>3 体系结构模式</h1><ol>
<li><p>MVC</p>
<blockquote>
<p>M：管理系统数据和在数据上的操作</p>
<p>V：定义和管理如何显示数据给用户</p>
<p>C：管理用户的交互</p>
</blockquote>
</li>
<li><p>分层体系结构</p>
<blockquote>
<ol>
<li>系统支持（操作系统、数据库等）</li>
<li>核心业务逻辑/应用功能 系统实用程序</li>
<li>用户界面管理 身份验证和授权</li>
<li>用户界面</li>
</ol>
</blockquote>
</li>
<li><p>容器体系结构</p>
<blockquote>
<p>系统所有数据在一个中央容器中管理，该中央容器可被所有系统组件访问。组件间不直接交互，它们只通过容器进行交互</p>
<p>​        例子：IDE</p>
<p>使用时机：一个系统中所生成的大量信息需要持久保存时，可以使用该模式。也可以在数据驱动系统中使用该模式，每当在容器中收入数据时将触发一个动作或工具。</p>
<p>优点：组件独立</p>
<p>缺点：容器出问题，整个系统出问题</p>
</blockquote>
</li>
<li><p>C/S结构</p>
<blockquote>
<p>系统功能以服务形态存在，每一个服务来自于某个单独的服务器</p>
<p>优点：服务器可以分布在网络上</p>
</blockquote>
</li>
<li><p>管道和过滤器体系结构</p>
<blockquote>
<p>系统运行时组织的模型</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>有向图、无向图、有向网、无向网（邻接矩阵）</title>
    <url>/jaheel.github.io/2020/10/19/%E5%9B%BE-(%E6%9C%89%E5%90%91%E3%80%81%E6%97%A0%E5%90%91)(%E5%9B%BE%E3%80%81%E7%BD%91)(%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5)/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>页码：P162</p>
<p>算法： 7.1-7.2</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY INT_MAX <span class="comment">//最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20 <span class="comment">//最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VRType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> InfoType;</span><br><span class="line"><span class="comment">//&#123;有向图，有向网，无向图，无向网&#125;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>DG,DN,UDG,UDN&#125;GraphKind;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span> &#123;</span></span><br><span class="line">	VRType adj;<span class="comment">//VRType是顶点关系类型。对无权图，用1或0</span></span><br><span class="line">	<span class="comment">//表示相邻否；对带权图，则为权值类型</span></span><br><span class="line">	InfoType *info;<span class="comment">//该弧相关信息的指针</span></span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType vexs[MAX_VERTEX_NUM];<span class="comment">//顶点向量</span></span><br><span class="line">	AdjMatrix arcs;<span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">	GraphKind kind;<span class="comment">//图的种类标志</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在G中找到v对应的顶点位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph G, <span class="keyword">char</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  算法7.2</span></span><br><span class="line"><span class="comment">  采用数组（邻接矩阵）表示法，构造无向网G</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, w;</span><br><span class="line">	VertexType v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vexs[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;<span class="comment">//构造顶点向量</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G.arcs[i][j].adj = INFINITY;</span><br><span class="line">			G.arcs[i][j].info = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边vi、vj和权值w(int):&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		G.arcs[i][j].adj = w;<span class="comment">//弧&lt;v1,v2&gt;的权值</span></span><br><span class="line">		<span class="comment">//置&lt;v1,v2&gt;的对称弧&lt;v2,v1&gt;</span></span><br><span class="line">		G.arcs[j][i].adj = G.arcs[i][j].adj;</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateDN</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, w;</span><br><span class="line">	VertexType v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vexs[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;<span class="comment">//构造顶点向量</span></span><br><span class="line"> </span><br><span class="line">	 <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G.arcs[i][j].adj = INFINITY;</span><br><span class="line">			G.arcs[i][j].info = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边vi、vj和权值w(int):&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		G.arcs[i][j].adj = w;<span class="comment">//弧&lt;v1,v2&gt;的权值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有向图的构造</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateDG</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, w;</span><br><span class="line">	VertexType v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vexs[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;<span class="comment">//构造顶点向量</span></span><br><span class="line"> </span><br><span class="line">	 <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G.arcs[i][j].adj = <span class="number">0</span>;</span><br><span class="line">			G.arcs[i][j].info = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边vi、vj:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		G.arcs[i][j].adj = <span class="number">1</span>;<span class="comment">//1代表可达，0代表不可达</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">无向图的构造</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDG</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, w;</span><br><span class="line">	VertexType v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vexs[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;<span class="comment">//构造顶点向量</span></span><br><span class="line"> </span><br><span class="line">	 <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G.arcs[i][j].adj = <span class="number">0</span>;</span><br><span class="line">			G.arcs[i][j].info = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边vi、vj:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		G.arcs[i][j].adj = <span class="number">1</span>;<span class="comment">//1代表可达，0代表不可达</span></span><br><span class="line">		G.arcs[j][i].adj = G.arcs[i][j].adj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法7.1</span></span><br><span class="line"><span class="comment">采用数组（邻接矩阵）表示法，构造图G。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateGraph</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入图的种类：0表示DG，1表示DN，2表示UDG，3表示UDN&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	G.kind=(GraphKind)x;</span><br><span class="line">	<span class="keyword">switch</span> (G.kind)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DG:</span><br><span class="line">		<span class="keyword">return</span> CreateDG(G);</span><br><span class="line">	<span class="keyword">case</span> DN:</span><br><span class="line">		<span class="keyword">return</span> CreateDN(G);</span><br><span class="line">	<span class="keyword">case</span> UDG:</span><br><span class="line">		<span class="keyword">return</span> CreateUDG(G);</span><br><span class="line">	<span class="keyword">case</span> UDN:<span class="keyword">return</span> CreateUDN(G);</span><br><span class="line">	<span class="keyword">default</span>:<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出邻接矩阵：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">&quot;----&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (G.arcs[i][j].adj == INFINITY)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; <span class="string">&quot;∞&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; G.arcs[i][j].adj;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MGraph G;</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (x)</span><br><span class="line">	&#123;</span><br><span class="line">		CreateGraph(G);</span><br><span class="line">		<span class="built_in">list</span>(G);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;是否继续(1、继续，0、退出)&quot;</span>;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>图（Floyd算法）</title>
    <url>/jaheel.github.io/2020/10/19/%E5%9B%BE%EF%BC%88Floyd%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>页码：P191-192</p>
<p>实现：算法7.16（解析：图7.37）</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 32767 <span class="comment">//最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20 <span class="comment">//最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VRType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span>*** PathMatrix;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//&#123;有向图，有向网，无向图，无向网&#125;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> DG, DN, UDG, UDN &#125;GraphKind;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span> &#123;</span></span><br><span class="line">	VRType adj;<span class="comment">//VRType是顶点关系类型。对无权图，用1或0</span></span><br><span class="line">			   <span class="comment">//表示相邻否；对带权图，则为权值类型</span></span><br><span class="line">	InfoType *info;<span class="comment">//该弧相关信息的指针</span></span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> ArcCell** DistancMatrix;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType vexs[MAX_VERTEX_NUM];<span class="comment">//顶点向量</span></span><br><span class="line">	AdjMatrix arcs;<span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">	GraphKind kind;<span class="comment">//图的种类标志</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//在G中找到v对应的顶点位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph G, <span class="keyword">char</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateDN</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, w;</span><br><span class="line">	VertexType v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vexs[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;<span class="comment">//构造顶点向量</span></span><br><span class="line"> </span><br><span class="line">	 <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G.arcs[i][j].adj = INFINITY;</span><br><span class="line">			G.arcs[i][j].info = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line">			&#123;</span><br><span class="line">				G.arcs[i][j].adj = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边vi、vj和权值w(int):&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		G.arcs[i][j].adj = w;<span class="comment">//弧&lt;v1,v2&gt;的权值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出邻接矩阵：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">&quot;----&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (G.arcs[i][j].adj == INFINITY)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; <span class="string">&quot;∞&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; G.arcs[i][j].adj;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_FLOYD</span><span class="params">(MGraph G,PathMatrix &amp;P, DistancMatrix &amp;D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, v, w,u;</span><br><span class="line">	P = (<span class="keyword">bool</span> ***)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span> *)*G.vexnum);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">		P[i] = (<span class="keyword">bool</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*G.vexnum);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line">		P[i][j] = (<span class="keyword">bool</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*G.vexnum);</span><br><span class="line"> </span><br><span class="line">	D = (ArcCell **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcCell)*G.vexnum);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		D[i]= (ArcCell *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcCell)*G.vexnum);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//各对结点之间初始已知路径及距离</span></span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			D[v][w] = G.arcs[v][w];</span><br><span class="line">			<span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; G.vexnum; ++u)</span><br><span class="line">			&#123;</span><br><span class="line">				P[v][w][u] = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//从v到w有直接路径</span></span><br><span class="line">			<span class="keyword">if</span> (D[v][w].adj &lt; INFINITY&amp;&amp;D[v][w].adj!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				P[v][w][v] = TRUE;</span><br><span class="line">				P[v][w][w] = TRUE;</span><br><span class="line">			&#125;<span class="comment">//if</span></span><br><span class="line">		&#125;<span class="comment">//for</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; G.vexnum; ++u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//从v经u到w的一条路径更短</span></span><br><span class="line">				<span class="keyword">if</span> (D[v][u].adj + D[u][w].adj &lt; D[v][w].adj)</span><br><span class="line">				&#123;</span><br><span class="line">					D[v][w].adj = D[v][u].adj + D[u][w].adj;</span><br><span class="line">					<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">					&#123;</span><br><span class="line">						P[v][w][i] = P[v][u][i] || P[u][w][i];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="comment">//if</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出每一对顶点之间的最短路径长度如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; G.vexs[v] &lt;&lt; <span class="string">&quot;----&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (D[v][w].adj == INFINITY)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%4s&quot;</span>, <span class="string">&quot;∞&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, D[v][w].adj);			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MGraph G;</span><br><span class="line">	<span class="keyword">int</span> v0;</span><br><span class="line">	PathMatrix P;</span><br><span class="line">	DistancMatrix D;</span><br><span class="line">	CreateDN(G);</span><br><span class="line">	<span class="built_in">list</span>(G);</span><br><span class="line">	ShortestPath_FLOYD(G, P, D);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>图（Dijkstra算法）</title>
    <url>/jaheel.github.io/2020/10/19/%E5%9B%BE%EF%BC%88Dijkstra%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>页码：P189</p>
<p>实现：算法7.15</p>
<p>IDE：VS2015</p>
<p>代码如下：</p>
<a id="more"></a>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 32767 <span class="comment">//最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20 <span class="comment">//最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VRType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span>** PathMatrix;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//&#123;有向图，有向网，无向图，无向网&#125;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> DG, DN, UDG, UDN &#125;GraphKind;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span> &#123;</span></span><br><span class="line">	VRType adj;<span class="comment">//VRType是顶点关系类型。对无权图，用1或0</span></span><br><span class="line">			   <span class="comment">//表示相邻否；对带权图，则为权值类型</span></span><br><span class="line">	InfoType *info;<span class="comment">//该弧相关信息的指针</span></span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> ArcCell* ShortPathTable;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType vexs[MAX_VERTEX_NUM];<span class="comment">//顶点向量</span></span><br><span class="line">	AdjMatrix arcs;<span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">	GraphKind kind;<span class="comment">//图的种类标志</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//在G中找到v对应的顶点位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph G, <span class="keyword">char</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateDN</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, w;</span><br><span class="line">	VertexType v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vexs[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;<span class="comment">//构造顶点向量</span></span><br><span class="line"> </span><br><span class="line">	 <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G.arcs[i][j].adj = INFINITY;</span><br><span class="line">			G.arcs[i][j].info = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边vi、vj和权值w(int):&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		G.arcs[i][j].adj = w;<span class="comment">//弧&lt;v1,v2&gt;的权值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出邻接矩阵：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">&quot;----&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (G.arcs[i][j].adj == INFINITY)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; <span class="string">&quot;∞&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; G.arcs[i][j].adj;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(MGraph G, <span class="keyword">int</span> v0, PathMatrix &amp;P, ShortPathTable &amp;D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, v, w;</span><br><span class="line">	P = (<span class="keyword">bool</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span> *)*G.vexnum);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">		P[i] = (<span class="keyword">bool</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*G.vexnum);</span><br><span class="line">	D = (ArcCell *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcCell)*G.vexnum);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">bool</span> *<span class="keyword">final</span> = <span class="keyword">new</span> <span class="keyword">bool</span>[G.vexnum];</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span>[v] = FALSE;</span><br><span class="line">		D[v] = G.arcs[v0][v];</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			P[v][w] = FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (D[v].adj &lt; INFINITY)</span><br><span class="line">		&#123;</span><br><span class="line">			P[v][v0] = TRUE;</span><br><span class="line">			P[v][v] = TRUE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//for</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="comment">//初始化,v0顶点属于S集</span></span><br><span class="line">	D[v0].adj = <span class="number">0</span>; <span class="keyword">final</span>[v0] = TRUE;</span><br><span class="line">	<span class="comment">//开始主循环，每次求得v0到某个顶点的最短路径，并加v到S集</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INFINITY;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//w顶点在V-S中</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//w顶点离v0顶点更近</span></span><br><span class="line">				<span class="keyword">if</span> (D[w].adj &lt; min)</span><br><span class="line">				&#123;</span><br><span class="line">					v = w;</span><br><span class="line">					min = D[w].adj;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span>[v] = TRUE;<span class="comment">//离v0顶点最近的v加入S集</span></span><br><span class="line">		<span class="comment">//更新当前最短路径和距离</span></span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//修改D[w]和P[w]</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; (min + G.arcs[v][w].adj &lt; D[w].adj))</span><br><span class="line">			&#123;</span><br><span class="line">				D[w].adj = min + G.arcs[v][w].adj;</span><br><span class="line">				P[w] = P[v];</span><br><span class="line">				P[w][w] = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i!=v0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%3c  %3c  &quot;</span>,G.vexs[v0],G.vexs[i]);</span><br><span class="line">			<span class="keyword">if</span> (D[i].adj != INFINITY)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%5d    &quot;</span>, D[i]);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (P[i][j])</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; G.vexs[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MGraph G;</span><br><span class="line">	<span class="keyword">int</span> v0;</span><br><span class="line">	PathMatrix P;</span><br><span class="line">	ShortPathTable D;</span><br><span class="line">	CreateDN(G);</span><br><span class="line">	<span class="built_in">list</span>(G);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入源点序号v0:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; v0;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出从源点&quot;</span> &lt;&lt; v0 &lt;&lt; <span class="string">&quot;到其余顶点的最短路径如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;始点 终点 路径长度 最短路径&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ShortestPath_DIJ(G, v0, P, D);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>图（邻接表）（BFS、DFS）</title>
    <url>/jaheel.github.io/2020/10/19/%E5%9B%BE%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89%EF%BC%88BFS%E3%80%81DFS%EF%BC%89/</url>
    <content><![CDATA[<p>代码如下（附解析）：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20<span class="comment">//最大顶点个数</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;<span class="comment">//该弧所指向的顶点位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span><span class="comment">//指向下一条弧的指针</span></span><br><span class="line">	InfoType info;<span class="comment">//该弧相关信息的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">	VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">	ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode,AdjList[MAX_VERTEX_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AdjList vertices;</span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">	<span class="keyword">int</span> kind;<span class="comment">//图的种类标志</span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph G, <span class="keyword">char</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G.vertices[i].data == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   采用邻接表存储表示，构造无向图G</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDG</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, IncInfo;</span><br><span class="line">	ArcNode *pi, *pj;</span><br><span class="line">	<span class="keyword">char</span> v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vertices[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;].data:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//初始化链表头指针为空</span></span><br><span class="line">		G.vertices[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	   输入各边并构造邻接表</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边的两个顶点:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//输入一条边的起点和终点</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定V1和V2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		<span class="keyword">if</span> (!(pi = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="comment">//对弧结点赋邻接点&quot;位置&quot;信息</span></span><br><span class="line">		pi-&gt;adjvex = j;</span><br><span class="line">		pi-&gt;info = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//插入链表G.vertices[i]</span></span><br><span class="line">		pi-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">		G.vertices[i].firstarc = pi;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!(pj = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="comment">//对弧结点赋邻接点&quot;位置&quot;信息</span></span><br><span class="line">		<span class="comment">//插入链表G.vertices[j]</span></span><br><span class="line">		pj-&gt;adjvex = i;</span><br><span class="line">		pj-&gt;info = <span class="number">0</span>;</span><br><span class="line">		pj-&gt;nextarc = G.vertices[j].firstarc;</span><br><span class="line">		G.vertices[j].firstarc = pj;</span><br><span class="line">	&#125;<span class="comment">//for</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//CreateUDG</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//有向图</span></span><br><span class="line"><span class="function">Status <span class="title">CreateDG</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, IncInfo;</span><br><span class="line">	ArcNode *pi, *pj;</span><br><span class="line">	<span class="keyword">char</span> v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vertices[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;].data:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//初始化链表头指针为空</span></span><br><span class="line">		G.vertices[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输入各边并构造邻接表</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边的两个顶点:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//输入一条边的起点和终点</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定V1和V2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		<span class="keyword">if</span> (!(pi = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="comment">//对弧结点赋邻接点&quot;位置&quot;信息</span></span><br><span class="line">		pi-&gt;adjvex = j;</span><br><span class="line">		pi-&gt;info = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//插入链表G.vertices[i]</span></span><br><span class="line">		pi-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">		G.vertices[i].firstarc = pi;</span><br><span class="line">	&#125;<span class="comment">//for</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//CreateDG</span></span><br><span class="line"><span class="comment">//有向网</span></span><br><span class="line"><span class="function">Status <span class="title">CreateDN</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, IncInfo;</span><br><span class="line">	ArcNode *pi, *pj;</span><br><span class="line">	<span class="keyword">char</span> v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入是否有Info信息（0、没有，1、有）&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; IncInfo;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vertices[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;].data:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//初始化链表头指针为空</span></span><br><span class="line">		G.vertices[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输入各边并构造邻接表</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边的两个顶点和相连边的权值:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//输入一条边的起点和终点</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; IncInfo;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定V1和V2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		<span class="keyword">if</span> (!(pi = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="comment">//对弧结点赋邻接点&quot;位置&quot;信息</span></span><br><span class="line">		pi-&gt;adjvex = j;</span><br><span class="line">		<span class="comment">//插入链表G.vertices[i]</span></span><br><span class="line">		pi-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">		G.vertices[i].firstarc = pi;</span><br><span class="line">		</span><br><span class="line">		pi-&gt;info = IncInfo;</span><br><span class="line">	&#125;<span class="comment">//for</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//CreateDN</span></span><br><span class="line"><span class="comment">//无向网</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, IncInfo;</span><br><span class="line">	ArcNode *pi, *pj;</span><br><span class="line">	<span class="keyword">char</span> v1, v2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点数G.vexnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边数G.arcnum:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.arcnum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入是否有Info信息（0、没有，1、有）&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; IncInfo;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顶点G.vertices[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;].data:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//初始化链表头指针为空</span></span><br><span class="line">		G.vertices[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输入各边并构造邻接表</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;条边的两个顶点和相连边的权值:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//输入一条边的起点和终点</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v2;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; IncInfo;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="comment">//确定V1和V2在G中的位置</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">		<span class="keyword">if</span> (!(pi = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="comment">//对弧结点赋邻接点&quot;位置&quot;信息</span></span><br><span class="line">		pi-&gt;adjvex = j;</span><br><span class="line">		<span class="comment">//插入链表G.vertices[i]</span></span><br><span class="line">		pi-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">		G.vertices[i].firstarc = pi;</span><br><span class="line">		pi-&gt;info = IncInfo;</span><br><span class="line">		<span class="keyword">if</span> (!(pj = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="comment">//对弧结点赋邻接点&quot;位置&quot;信息</span></span><br><span class="line">		pj-&gt;adjvex = i;</span><br><span class="line">		<span class="comment">//插入链表G.vertices[i]</span></span><br><span class="line">		pj-&gt;nextarc = G.vertices[j].firstarc;</span><br><span class="line">		G.vertices[j].firstarc = pi;</span><br><span class="line">		pj-&gt;info = IncInfo;</span><br><span class="line">	&#125;<span class="comment">//for</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//CreateUDN</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateGraph</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入图的种类：0表示DG，1表示DN，2表示UDG，3表示UDN&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.kind;</span><br><span class="line">	<span class="keyword">switch</span> (G.kind)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> CreateDG(G);</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> CreateDN(G);</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> CreateUDG(G);</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">return</span> CreateUDN(G);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	ArcNode *p;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出邻接表（（0）代表无权值）：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;：&quot;</span> &lt;&lt; G.vertices[i].data;</span><br><span class="line">		p = G.vertices[i].firstarc;</span><br><span class="line">		<span class="keyword">while</span> (p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; p-&gt;adjvex;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt;p-&gt;info&lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">			p = p-&gt;nextarc;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ArcNode *p;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	visited[v] = TRUE;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; G.vertices[v].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (p = G.vertices[v].firstarc; p; p = p-&gt;nextarc)</span><br><span class="line">	&#123;</span><br><span class="line">		w = p-&gt;adjvex;</span><br><span class="line">		<span class="keyword">if</span> (!visited[w])<span class="comment">//对v的尚未访问的邻接顶点w递归调用DFS</span></span><br><span class="line">			DFS(G, w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		visited[v] = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[v])</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G, v);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v,w;</span><br><span class="line">	<span class="comment">//辅助队列</span></span><br><span class="line">	<span class="keyword">int</span> front=<span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">	VNode Queue[MAX_VERTEX_NUM];</span><br><span class="line">	ArcNode *p;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//初始化标志数组</span></span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		visited[v] = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[v])<span class="comment">//v尚未访问</span></span><br><span class="line">		&#123;</span><br><span class="line">			visited[v] =<span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; G.vertices[v].data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			Queue[++rear] = G.vertices[v];<span class="comment">//v入队列</span></span><br><span class="line">			<span class="keyword">while</span> (front != rear)<span class="comment">//判断队列是否为空</span></span><br><span class="line">			&#123;</span><br><span class="line">				VNode u = Queue[++front];<span class="comment">//队头元素出队列，并等于u</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				判断该结点的后序表结点,存在即输出，入队列</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="keyword">for</span> (p = u.firstarc; p; p = p-&gt;nextarc)</span><br><span class="line">				&#123;</span><br><span class="line">					w = p-&gt;adjvex;</span><br><span class="line">					<span class="keyword">if</span> (!visited[w])</span><br><span class="line">					&#123;</span><br><span class="line">						visited[w] = <span class="literal">true</span>;</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; G.vertices[w].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">						Queue[++rear] = G.vertices[w];</span><br><span class="line">					&#125;<span class="comment">//if</span></span><br><span class="line">				&#125;<span class="comment">//for</span></span><br><span class="line">			&#125;<span class="comment">//while</span></span><br><span class="line">		&#125;<span class="comment">//if</span></span><br><span class="line">	&#125;<span class="comment">//for</span></span><br><span class="line">&#125;<span class="comment">//BFSTraverse</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ALGraph G;</span><br><span class="line">	CreateGraph(G);</span><br><span class="line">	<span class="built_in">list</span>(G);</span><br><span class="line">	<span class="comment">//深度优先遍历图</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;深度优先遍历：&quot;</span>;</span><br><span class="line">	DFSTraverse(G);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//广度优先遍历</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;广度优先遍历：&quot;</span>;</span><br><span class="line">	BFSTraverse(G);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>排序（堆排序）</title>
    <url>/jaheel.github.io/2020/10/19/%E6%8E%92%E5%BA%8F%EF%BC%88%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RedType rc = H.r[s];</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j &lt; m&amp;&lt;(H.r[j].key, H.r[j + <span class="number">1</span>].key))</span><br><span class="line">			++j;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!LT(rc.key, H.r[j].key))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		H.r[s] = H.r[j];</span><br><span class="line">		s = j;</span><br><span class="line">	&#125;</span><br><span class="line">	H.r[s] = rc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对顺序表H进行堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//建立最大堆</span></span><br><span class="line">	<span class="keyword">for</span> (i = H.length / <span class="number">2</span>; i &gt;=<span class="number">1</span>; --i)</span><br><span class="line">		HeapAdjust(H, i, H.length);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (i = H.length; i &gt;=<span class="number">2</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		RedType temp = H.r[<span class="number">1</span>];</span><br><span class="line">		H.r[<span class="number">1</span>] = H.r[i];</span><br><span class="line">		H.r[i] = temp;</span><br><span class="line"> </span><br><span class="line">		HeapAdjust(H, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>数组（顺序存储）</title>
    <url>/jaheel.github.io/2020/10/19/%E6%95%B0%E7%BB%84%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>IDE: VS2015</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARRAY_DIM 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *base;<span class="comment">//数组元素基址</span></span><br><span class="line">	<span class="keyword">int</span> dim;<span class="comment">//数组维数</span></span><br><span class="line">	<span class="keyword">int</span> *bounds;<span class="comment">//数组维界基址</span></span><br><span class="line">	<span class="keyword">int</span> *constants;<span class="comment">//数组映像函数常量基址</span></span><br><span class="line">&#125;Array;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitArray</span><span class="params">(Array &amp;A, <span class="keyword">int</span> dim,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dim&lt;<span class="number">1</span> || dim&gt;MAX_ARRAY_DIM)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	A.dim = dim;</span><br><span class="line">	A.bounds = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(dim*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	va_list ap;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> elemtotal = <span class="number">1</span>;<span class="comment">//A的元素总数</span></span><br><span class="line">	va_start(ap, dim);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dim; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		A.bounds[i] = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">		<span class="keyword">if</span> (A.bounds[i] &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> UNDERFLOW;</span><br><span class="line">		elemtotal *= A.bounds[i];</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(ap);</span><br><span class="line">	A.base = (ElemType *)<span class="built_in">malloc</span>(elemtotal * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	</span><br><span class="line">	A.constants = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(dim * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	</span><br><span class="line">	A.constants[dim - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = dim - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		A.constants[i] = A.bounds[i + <span class="number">1</span>] * A.constants[i + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">DestroyArray</span><span class="params">(Array &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!A.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="built_in">free</span>(A.base);</span><br><span class="line">	A.base = ERROR;</span><br><span class="line">	<span class="keyword">if</span> (!A.bounds)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="built_in">free</span>(A.bounds);</span><br><span class="line">	A.bounds = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!A.constants)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="built_in">free</span>(A.constants);</span><br><span class="line">	A.constants = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Locate</span><span class="params">(Array &amp;A, va_list ap, <span class="keyword">int</span> &amp;off)</span><span class="comment">//若ap指示的各下标合法，则求出该元素在A中的相对地址off</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	off = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ind;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.dim; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		 ind = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">		<span class="keyword">if</span> (ind &lt; <span class="number">0</span> || ind &gt;= A.bounds[i])</span><br><span class="line">			<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">		off += A.constants[i] * ind;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Value</span><span class="params">(Array A, ElemType *e, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	</span><br><span class="line">	va_start(ap, e);</span><br><span class="line">	Status result;</span><br><span class="line">	<span class="keyword">int</span> off;</span><br><span class="line">	<span class="keyword">if</span> ((result = Locate(A, ap, off)) &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	*e = *(A.base + off);</span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Assign</span><span class="params">(Array &amp;A, ElemType e, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	va_start(ap, e);</span><br><span class="line">	Status result;</span><br><span class="line">	<span class="keyword">int</span> off;</span><br><span class="line">	<span class="keyword">if</span> ((result = Locate(A, ap, off)) &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	*(A.base + off) = e;</span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array A;</span><br><span class="line">	ElemType e;</span><br><span class="line">	InitArray(A, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	Assign(A, <span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (Value(A, &amp;e,<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出e的值:&quot;</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (DestroyArray(A) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组A销毁成功!&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>C++</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>排序（快速排序）</title>
    <url>/jaheel.github.io/2020/10/19/%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>页码：P272-276</p>
<p>实现：算法10.6-10.8</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LT(a,b) (a&lt;b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EQ(a,b) (a==b)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">	InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;RedType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	RedType r[MAXSIZE + <span class="number">1</span>];<span class="comment">//r[0]闲置或用作哨兵单位</span></span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//顺序表长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表类型</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//构造一个空的顺序表L</span></span><br><span class="line">	L.length = <span class="number">0</span>;<span class="comment">//空表长度为0</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建n个元素的顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">CreateList</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; L.r[i].key;</span><br><span class="line">		++L.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;<span class="comment">//创建失败</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">DispList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; L.r[i].key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L.r[<span class="number">0</span>] = L.r[low];</span><br><span class="line">	<span class="keyword">int</span> pivotkey = L.r[low].key;</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high&amp;&amp;L.r[high].key &gt;= pivotkey)</span><br><span class="line">			--high;</span><br><span class="line">		L.r[low] = L.r[high];</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high&amp;&amp;L.r[low].key &lt;= pivotkey)</span><br><span class="line">			++low;</span><br><span class="line">		L.r[high] = L.r[low];</span><br><span class="line">	&#125;</span><br><span class="line">	L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> pivotloc = Partition(L, low, high);</span><br><span class="line">		QSort(L, low, pivotloc - <span class="number">1</span>);<span class="comment">//对底子表递归排序</span></span><br><span class="line">		QSort(L, pivotloc + <span class="number">1</span>, high);<span class="comment">//对高子表递归排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSort(L, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;初始化顺序表，&quot;</span>;</span><br><span class="line">	InitList(L);</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;顺序表为空！\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入顺序表的元素个数:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	CreateList(L, n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个元素的顺序表如下:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	DispList(L);</span><br><span class="line">	QuickSort(L);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;快速排序结果如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	DispList(L);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>查找（二叉排序树）</title>
    <url>/jaheel.github.io/2020/10/19/%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构 P227-231</p>
<p>实现：算法9.5-9.8</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EQ(a,b) (a==b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LT(a,b) (a&lt;b)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	KeyType key;<span class="comment">//关键字域</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree &amp;T,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		T-&gt;data = e;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关键字已存在于树中，插入失败，返回0</span></span><br><span class="line">		<span class="keyword">if</span> (e.key == T-&gt;data.key)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (e.key &lt; T-&gt;data.key)</span><br><span class="line">			<span class="keyword">return</span> InsertBST(T-&gt;lchild, e);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> InsertBST(T-&gt;rchild, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T-&gt;data.key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild)</span><br><span class="line">			PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;rchild)</span><br><span class="line">			PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild)</span><br><span class="line">			InOrderTraverse(T-&gt;lchild);</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T-&gt;data.key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (T-&gt;rchild)</span><br><span class="line">			InOrderTraverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild)</span><br><span class="line">			PostOrderTraverse(T-&gt;lchild);		</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;rchild)</span><br><span class="line">			PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T-&gt;data.key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找关键字</span></span><br><span class="line"><span class="function">BiTree <span class="title">SearchBSTa</span><span class="params">(BiTree T, KeyType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;data.key == e)</span><br><span class="line">			<span class="keyword">return</span> T;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (e &lt; T-&gt;data.key)</span><br><span class="line">			<span class="keyword">return</span> SearchBSTa(T-&gt;lchild, e);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> SearchBSTa(T-&gt;rchild, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除确定结点</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTNode *p=<span class="keyword">new</span> BiTNode();</span><br><span class="line">	<span class="comment">//右子树为空</span></span><br><span class="line">	<span class="keyword">if</span> (!T-&gt;rchild)</span><br><span class="line">	&#123;</span><br><span class="line">		p = T;</span><br><span class="line">		T = T-&gt;lchild;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左子树为空</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!T-&gt;lchild)</span><br><span class="line">	&#123;</span><br><span class="line">		p = T;</span><br><span class="line">		T = T-&gt;rchild;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//左右子树均不空</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = T;</span><br><span class="line">		BiTNode *s = <span class="keyword">new</span> BiTNode();</span><br><span class="line">		s = T-&gt;lchild;</span><br><span class="line">		<span class="keyword">while</span> (s-&gt;rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			T = s;</span><br><span class="line">			s = s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		T-&gt;data = s-&gt;data;</span><br><span class="line">		<span class="keyword">if</span> (p != T)</span><br><span class="line">			p-&gt;rchild = s-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			T-&gt;lchild = s-&gt;lchild;</span><br><span class="line">		<span class="keyword">delete</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到删除的结点</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree &amp;T, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (EQ(key, T-&gt;data.key))</span><br><span class="line">			<span class="keyword">return</span> Delete(T);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</span><br><span class="line">			<span class="keyword">return</span> DeleteBST(T-&gt;lchild, key);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> DeleteBST(T-&gt;rchild, key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//DeleteBST</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree T = <span class="literal">NULL</span>, s;</span><br><span class="line">	<span class="keyword">int</span> n, i;</span><br><span class="line">	ElemType e;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入二叉排序树的结点数：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个结点的值:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; e.key;</span><br><span class="line">		InsertBST(T, e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PreOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PostOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入要查找结点的值：\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; e.key;</span><br><span class="line">	s = SearchBSTa(T, e.key);</span><br><span class="line">	<span class="keyword">if</span> (s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;已找到！结点的八进制地址为：%o\n&quot;</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入插入结点的值：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; e.key;</span><br><span class="line">	InsertBST(T, e);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PreOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PostOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入要删除结点的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; e.key;</span><br><span class="line">	DeleteBST(T, e.key);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PreOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历二叉排序树，结果是：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PostOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title>栈（实现、应用）</title>
    <url>/jaheel.github.io/2020/10/19/%E6%A0%88%EF%BC%88%E5%AE%9E%E7%8E%B0%E3%80%81%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>页码：P46</p>
<p>实现：</p>
<ol>
<li>初始化顺序栈</li>
<li>创建顺序栈</li>
<li>判断栈空</li>
<li>输出顺序栈</li>
<li>取栈顶元素</li>
<li>入栈</li>
<li>出栈</li>
</ol>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType *base;</span><br><span class="line">	SElemType *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.base = (SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">	<span class="keyword">if</span> (!S.base)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	 e=  *(S.top<span class="number">-1</span>);</span><br><span class="line">	 <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top - S.base &gt;= S.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		S.base = (SElemType *)<span class="built_in">realloc</span>(S.base, (S.stacksize + STACKINCREMENT) * <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">		<span class="keyword">if</span> (!S.base)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		S.top = S.base + S.stacksize;</span><br><span class="line">		S.stacksize += STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++ = e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e = *--S.top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Stackoutput</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SElemType *p;</span><br><span class="line">	<span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = S.base;</span><br><span class="line">	<span class="keyword">while</span> (p != S.top)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p);</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SElemType *p;</span><br><span class="line">	<span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = S.top - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != S.base - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p);</span><br><span class="line">		p--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n, k, h, a, b;</span><br><span class="line">	SqStack S;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建一个空栈!\n&quot;</span>);</span><br><span class="line">	InitStack(S);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;判断栈是否为空！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;StackEmpty(S)=%d\n&quot;</span>, StackEmpty(S));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建栈的元素个数：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入%d个入栈元素的值：\n&quot;</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">		Push(S, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;逆序输出顺序栈元素值：\n&quot;</span>);</span><br><span class="line">	Stackoutput(S);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出顺序栈元素值：\n&quot;</span>);</span><br><span class="line">	StackTraverse(S);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入入栈元素值：&quot;</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; h;</span><br><span class="line">	Push(S, h);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出入栈后的顺序栈元素值：\n&quot;</span>);</span><br><span class="line">	StackTraverse(S);</span><br><span class="line">	Pop(S, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出第一个出栈元素值：%d\n&quot;</span>, a);</span><br><span class="line">	Pop(S, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出第二个出栈元素值：%d\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出两次出栈后顺序栈元素值：&quot;</span>);</span><br><span class="line">	StackTraverse(S);</span><br><span class="line">	GetTop(S, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出栈顶元素值：%d\n&quot;</span>, b);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>特征选择与稀疏学习</title>
    <url>/jaheel.github.io/2020/10/19/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>特征(feature)</p>
<p>相关特征(relevant feature)</p>
<p>无关特征(irrelevant feature)</p>
<p>特征选择(feature selection)</p>
<blockquote>
<p>从给定的特征集合中选择出相关特征子集的过程</p>
</blockquote>
<p>冗余特征(redundant feature)</p>
<p>“前向”搜索</p>
<blockquote>
<p>逐渐增加相关特征的策略</p>
</blockquote>
<p>“后向”搜索</p>
<blockquote>
<p>每次尝试去掉一个无关特征，逐渐减少特征</p>
</blockquote>
<p>“双向”搜索</p>
<blockquote>
<p>将前向和后向搜索结合起来</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵</title>
    <url>/jaheel.github.io/2020/10/19/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>页码：P99</p>
<p>IDE：VS2015</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MU 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NU 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 12500</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> i, j;<span class="comment">//该非零元的行下标和列下标</span></span><br><span class="line">	ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Triple data[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> mu, nu, tu;<span class="comment">//矩阵的行数、列数、非零元个数</span></span><br><span class="line">&#125;TSMatrix;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateMatrix</span><span class="params">(TSMatrix &amp;M)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> e, i, j, k = <span class="number">1</span>;</span><br><span class="line">	M.mu = MU;</span><br><span class="line">	M.nu = NU;</span><br><span class="line">	srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	M.tu = rand() % <span class="number">15</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M.mu;i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; M.nu; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			e = rand() % <span class="number">30</span>;</span><br><span class="line">			<span class="keyword">if</span> (e != <span class="number">0</span>) &#123;</span><br><span class="line">				M.data[k].i = i;</span><br><span class="line">				M.data[k].j = j;</span><br><span class="line">				M.data[k].e = e;</span><br><span class="line">				k++;</span><br><span class="line">				<span class="keyword">if</span> (k == M.tu)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(TSMatrix M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mu=%-2d, nu=%-2d, tu=%-2d&quot;</span>, M.mu, M.nu, M.tu);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= M.tu; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i=%-2d, j=%-2d, e=%-2d&quot;</span>, M.data[k].i, M.data[k].j, M.data[k].e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">TransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T.mu = M.nu;</span><br><span class="line">	T.nu = M.mu;</span><br><span class="line">	T.tu = M.tu;</span><br><span class="line">	<span class="keyword">if</span> (T.tu)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>;col&lt;=M.mu;++col)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= M.tu; ++p)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (M.data[p].j == col)</span><br><span class="line">				&#123;</span><br><span class="line">					T.data[q].i = M.data[p].j;</span><br><span class="line">					T.data[q].j = M.data[p].i;</span><br><span class="line">					T.data[q].e = M.data[p].e;</span><br><span class="line">					++q;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T.mu = M.nu;</span><br><span class="line">	T.nu = M.mu;</span><br><span class="line">	T.tu = M.tu;</span><br><span class="line">	<span class="keyword">int</span> col, t, q, p;</span><br><span class="line">	<span class="keyword">int</span> num[NU];</span><br><span class="line">	<span class="keyword">int</span> cpot[NU];</span><br><span class="line">	<span class="keyword">if</span> (T.tu)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= M.nu; ++col)</span><br><span class="line">			num[col] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (t = <span class="number">1</span>; t &lt;= M.tu; ++t)</span><br><span class="line">			++num[M.data[t].j];</span><br><span class="line">		cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (col = <span class="number">2</span>; col &lt;= M.nu; ++col)</span><br><span class="line">			cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (p = <span class="number">1</span>; p &lt;= M.tu; ++p)</span><br><span class="line">		&#123;</span><br><span class="line">			col = M.data[p].j;</span><br><span class="line">			q = cpot[col];</span><br><span class="line">			T.data[q].i = M.data[p].j;</span><br><span class="line">			T.data[q].j = M.data[p].i;</span><br><span class="line">			T.data[q].e = M.data[p].e;</span><br><span class="line">			++cpot[col];</span><br><span class="line">		&#125;<span class="comment">//for</span></span><br><span class="line">	&#125;<span class="comment">//if</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TSMatrix M, T,R;</span><br><span class="line">	CreateMatrix(M);</span><br><span class="line">	TransposeSMatrix(M, T);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出稀疏矩阵M：\n&quot;</span>);</span><br><span class="line">	print(M);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出转置矩阵T：\n&quot;</span>);</span><br><span class="line">	print(T);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	FastTransposeSMatrix(M, R);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出快速转置矩阵R：\n&quot;</span>);</span><br><span class="line">	print(R);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Algorithm</tag>
        <tag>data structrue</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>线索二叉树（建立、遍历）（前、中、后序）</title>
    <url>/jaheel.github.io/2020/10/19/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%BB%BA%E7%AB%8B%E3%80%81%E9%81%8D%E5%8E%86%EF%BC%89%EF%BC%88%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  定义线索二叉树的数据结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;<span class="comment">//结点对应的数据</span></span><br><span class="line">	<span class="keyword">int</span> ltag, rtag;<span class="comment">//左右孩子标记</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>;</span><span class="comment">//左孩子</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">rchild</span>;</span><span class="comment">//右孩子</span></span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   输出对应结点里面的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">PrintElement</span><span class="params">(TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">寻找p结点在Thrt树中的父节点，便于进行后序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BiThrTree <span class="title">parent</span><span class="params">(BiThrTree &amp;Thrt, BiThrTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiThrTree temp=Thrt-&gt;lchild;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (p==Thrt-&gt;lchild)<span class="comment">//p即为根节点，返回创建的头结点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Thrt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (temp-&gt;lchild == p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> temp;<span class="comment">//父节点就是我们寻找的结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp = temp-&gt;lchild;</span><br><span class="line">		<span class="keyword">while</span> (temp-&gt;lchild != p&amp;&amp;temp-&gt;rchild != p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			如果节点有右孩子，那就往右</span></span><br><span class="line"><span class="comment">			如果节点没有右孩子，就往左</span></span><br><span class="line"><span class="comment">			没有左孩子，就往前驱</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				temp = temp-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp = temp-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建线索二叉树，初始化跟二叉树的初始化递归算法一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiThrTree</span><span class="params">(BiThrTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(T = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode))))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"> </span><br><span class="line">		T-&gt;data = ch;</span><br><span class="line">		T-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">		T-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">		CreateBiThrTree(T-&gt;lchild);</span><br><span class="line">		CreateBiThrTree(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    T指向头结点，头结点的左链lchild指向根节点</span></span><br><span class="line"><span class="comment">	中序遍历二叉线索树T的非递归算法，对每个数据元素调用函数Visit</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T, Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiThrTree p = T-&gt;lchild;</span><br><span class="line">	<span class="keyword">while</span> (p&amp;&amp;(p != T))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">		&#123;			</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		Visit(p-&gt;data);</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;rtag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != T)</span><br><span class="line">		&#123;</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">			Visit(p-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   前序遍历二叉树非递归算法(仿造中序遍历）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse_Thr</span><span class="params">(BiThrTree T, Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiThrTree p = T;</span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Visit(p-&gt;data);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;		</span><br><span class="line">		Visit(p-&gt;data);</span><br><span class="line">		p = p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   后序遍历二叉树非递归算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse_Thr</span><span class="params">(BiThrTree T, Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiThrTree p = T-&gt;lchild;</span><br><span class="line">	BiThrTree pre = T;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//p指向第一个被访问结点</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>||p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p != T) </span><br><span class="line">	&#123;</span><br><span class="line">		Visit(p-&gt;data);</span><br><span class="line">		pre = parent(T, p);<span class="comment">//找到该节点的双亲</span></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (T == pre)<span class="comment">//如果双亲是T，就说明p是根节点，无后继</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = T;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果p是双亲的右孩子，或者双亲无右孩子，则后继为双亲</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p==pre-&gt;rchild||pre-&gt;rtag==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p = pre;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//若p的双亲有右孩子，后继为双亲右子树上后序遍历的第一个孩子</span></span><br><span class="line">			<span class="keyword">while</span> (pre-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				pre = pre-&gt;rchild;</span><br><span class="line">				<span class="keyword">while</span> (pre-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					pre = pre-&gt;lchild;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			p = pre;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  中序遍历进行二叉树线索化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p,BiThrTree &amp;pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		InThreading(p-&gt;lchild,pre);<span class="comment">//左子树线索化</span></span><br><span class="line">		<span class="keyword">if</span> (!p-&gt;lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">			p-&gt;lchild = pre;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((!pre-&gt;rchild)&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">			pre-&gt;rchild = p;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;</span><br><span class="line">		InThreading(p-&gt;rchild, pre);<span class="comment">//右子树线索化</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   前序遍历进行二叉树线索化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preThreading</span><span class="params">(BiThrTree p, BiThrTree &amp;pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;lchild = pre;</span><br><span class="line">			p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pre != <span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;rchild = p;</span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">			preThreading(p-&gt;lchild, pre);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">			preThreading(p-&gt;rchild, pre);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   后序遍历进行线索二叉树化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postThreading</span><span class="params">(BiThrTree p, BiThrTree &amp;pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">	postThreading(p-&gt;lchild, pre);</span><br><span class="line">	postThreading(p-&gt;rchild, pre);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;lchild==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;lchild = pre;</span><br><span class="line">		p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pre != <span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pre-&gt;rchild = p;</span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pre = p;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   中序遍历二叉树T，并将其中序线索化，Thrt指向头结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt, BiThrTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//建立头结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(Thrt = (BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode))))</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Thrt-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">	Thrt-&gt;rtag = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">	Thrt-&gt;rchild = Thrt;<span class="comment">//右指针回指</span></span><br><span class="line">	BiThrTree pre;</span><br><span class="line">	<span class="keyword">if</span> (!T)</span><br><span class="line">		Thrt-&gt;lchild = Thrt;<span class="comment">//若二叉树为空，则指针回指</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Thrt-&gt;lchild = T;</span><br><span class="line">		pre = Thrt;</span><br><span class="line">		InThreading(T,pre);<span class="comment">//中序遍历进行中序线索化</span></span><br><span class="line">		pre-&gt;rchild = Thrt;<span class="comment">//最后一个结点线索化</span></span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">		Thrt-&gt;rchild = pre;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   后序遍历二叉树，并将其线索化，原理同中序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderThreading</span><span class="params">(BiThrTree &amp;Thrt, BiThrTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//建立头结点</span></span><br><span class="line">	<span class="keyword">if</span> (!(Thrt = (BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode))))</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Thrt-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">	Thrt-&gt;rtag = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">	Thrt-&gt;rchild = Thrt;<span class="comment">//右指针回指</span></span><br><span class="line">	BiThrTree pre;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!T)</span><br><span class="line">		Thrt-&gt;lchild = Thrt;<span class="comment">//若二叉树为空，则指针回指</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Thrt-&gt;lchild = T;</span><br><span class="line">		pre = <span class="literal">NULL</span>;</span><br><span class="line">		postThreading(T, pre);<span class="comment">//后序遍历进行后序线索化</span></span><br><span class="line">		pre-&gt;rchild = Thrt;</span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">		Thrt-&gt;rchild = pre;<span class="comment">//最后一个结点线索化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	BiThrTree T1, Thrt1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;创建线索二叉树，按先序次序输入线索二叉树中结点的值：\n&quot;</span>;</span><br><span class="line">	CreateBiThrTree(T1);</span><br><span class="line">	<span class="keyword">if</span> (InOrderThreading(Thrt1, T1) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功建立中序线索化链表！\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历线索二叉树，结果是：\n&quot;</span>;</span><br><span class="line">	InOrderTraverse_Thr(Thrt1, PrintElement);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	BiThrTree T2;</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;创建线索二叉树，按先序次序输入线索二叉树中结点的值：\n&quot;</span>;</span><br><span class="line">	CreateBiThrTree(T2);</span><br><span class="line">	BiThrTree test1 = T2;</span><br><span class="line">	preThreading(T2, test1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;前序遍历线索二叉树，结果是：\n&quot;</span>;</span><br><span class="line">	PreOrderTraverse_Thr(T2, PrintElement);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	BiThrTree T3,Thrt3;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;创建线索二叉树，按先序次序输入线索二叉树中结点的值：\n&quot;</span>;</span><br><span class="line">	CreateBiThrTree(T3);</span><br><span class="line">	<span class="keyword">if</span> (PostOrderThreading(Thrt3, T3) == OK)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功建立后序序线索化链表！\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历线索二叉树，结果是：\n&quot;</span>;</span><br><span class="line">	PostOrderTraverse_Thr(Thrt3, PrintElement);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表（动态分配 逆置、排序）</title>
    <url>/jaheel.github.io/2020/10/19/%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D-%E9%80%86%E7%BD%AE%E3%80%81%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<ol>
<li><p>结构：线性表动态分配顺序存储结构</p>
</li>
<li><p>目的：逆置</p>
<a id="more"></a>
</li>
<li><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L.elem = (ElemType *)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span> (!L.elem)</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.listsize = LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">ListCreate_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.elem[i] = rand() % <span class="number">90</span> + <span class="number">10</span>;</span><br><span class="line">		++L.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">ListOutput_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L.elem[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">ListConverse_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ElemType temp;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = L.elem[i];</span><br><span class="line">		L.elem[i] = L.elem[L.length - <span class="number">1</span> - i];</span><br><span class="line">		L.elem[L.length - <span class="number">1</span> - i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Initialize the sequential list!&quot;</span>);</span><br><span class="line">	InitList_Sq(L);</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;The sequential list is empty!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Create the sequential list!\n&quot;</span>);</span><br><span class="line">	ListCreate_Sq(L, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Output all elements of the sequential list!\n&quot;</span>);</span><br><span class="line">	ListOutput_Sq(L);</span><br><span class="line">	ListConverse_Sq(L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Output all converse elements of the sequential list\n&quot;</span>);</span><br><span class="line">	ListOutput_Sq(L);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> j;<span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line">	system(<span class="string">&quot;puase&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p>结构：带头结点线性链表</p>
</li>
<li><p>目的：逆置，不另设新空间</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	q = L;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		p-&gt;data = rand() % <span class="number">90</span> + <span class="number">10</span>;</span><br><span class="line">		q-&gt;next = p;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">OutputList_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p = L-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">ListConverse_L</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q-&gt;next = L-&gt;next;</span><br><span class="line">		L-&gt;next=q;</span><br><span class="line">	    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList L;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Create the linked list,&quot;</span>);</span><br><span class="line">	CreateList_L(L, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Output all elements of the linked list!\n&quot;</span>);</span><br><span class="line">	OutputList_L(L);</span><br><span class="line">	ListConverse_L(L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Output all converse elements of the linked list!\n&quot;</span>);</span><br><span class="line">	OutputList_L(L);</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p>结构：线性表动态分配顺序存储结构</p>
</li>
<li><p>目的：实现顺序表中数据元素按值非递减排列</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TURE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L.elem = (ElemType *)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span> (!L.elem)</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.listsize = LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">ListCreate_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.elem[i] = rand() % <span class="number">90</span> + <span class="number">10</span>;</span><br><span class="line">		++L.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">ListOutput_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L.elem[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = L.elem[low];</span><br><span class="line">	<span class="keyword">int</span> pivotkey = L.elem[low];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high&amp;&amp;L.elem[high] &gt;= pivotkey)</span><br><span class="line">			--high;</span><br><span class="line">	   L.elem[low] = L.elem[high];</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high&amp;&amp;L.elem[low] &lt;= pivotkey)</span><br><span class="line">			++low;</span><br><span class="line">		L.elem[high] = L.elem[low];</span><br><span class="line">	&#125;</span><br><span class="line">	L.elem[low] = temp;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pivotloc = Partition(L, low, high);</span><br><span class="line">		QSort(L, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">		QSort(L, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListSort_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSort(L, <span class="number">0</span>, L.length<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	InitList_Sq(L);</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;The sequential list is empty!\n&quot;</span>);</span><br><span class="line">	ListCreate_Sq(L, <span class="number">5</span>);</span><br><span class="line">	ListOutput_Sq(L);</span><br><span class="line">	ListSort_Sq(L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sorted:\n&quot;</span>);</span><br><span class="line">	ListOutput_Sq(L);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p>结构：带头结点的线性链表L</p>
</li>
<li><p>目的：数据元素按值非递减排列</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	q = L;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		p-&gt;data = rand() % <span class="number">90</span> + <span class="number">10</span>;</span><br><span class="line">		q-&gt;next = p;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">OutputList_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p = L-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">result</span><span class="params">(LinkList L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LinkList <span class="title">par</span><span class="params">(LinkList L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = result(L,low);</span><br><span class="line">	<span class="keyword">int</span> pivotkey = result(L,low);</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		p = par(L, low);</span><br><span class="line">		q = par(L, high);</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; q-&gt;data &gt;= pivotkey)</span><br><span class="line">		&#123;</span><br><span class="line"> </span><br><span class="line">			--high;</span><br><span class="line">			q = par(L, high);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		p-&gt;data = q-&gt;data;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(L + low)-&gt;data = (L + high)-&gt;data;</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; p-&gt;data &lt;= pivotkey)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			++low;</span><br><span class="line">			p = par(L, low);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		q-&gt;data = p-&gt;data;</span><br><span class="line">		<span class="comment">//(L + high)-&gt;data = (L + low)-&gt;data;</span></span><br><span class="line">	&#125;</span><br><span class="line">	p = par(L, low);</span><br><span class="line">	p-&gt;data = temp;</span><br><span class="line">	<span class="comment">//(L + low)-&gt;data = temp;</span></span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pivotloc = Partition(L, low, high);</span><br><span class="line">		</span><br><span class="line">		QSort(L, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">		QSort(L, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListSort_Sq</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p = L-&gt;next;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++i;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	QSort(L, <span class="number">1</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList L;</span><br><span class="line">	CreateList_L(L, <span class="number">5</span>);</span><br><span class="line">	OutputList_L(L);</span><br><span class="line">	ListSort_Sq(L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sorted:&quot;</span>);</span><br><span class="line">	OutputList_L(L);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>计算学习理论</title>
    <url>/jaheel.github.io/2020/10/19/%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p><a href="https://books.google.com.hk/books?id=n79Zh2JzBhYC&pg=RA1-PA930&lpg=RA1-PA930&dq=PAC学习&source=bl&ots=bfMpxn5sUv&sig=ACfU3U2S6oXxodelVkXqKmwUxsX6EynaoA&hl=en&sa=X&ved=2ahUKEwic2IP7nsXqAhUSPXAKHQnGBo4Q6AEwBnoECA8QAQ#v=onepage&q=PAC学习&f=false">https://books.google.com.hk/books?id=n79Zh2JzBhYC&amp;pg=RA1-PA930&amp;lpg=RA1-PA930&amp;dq=PAC%E5%AD%A6%E4%B9%A0&amp;source=bl&amp;ots=bfMpxn5sUv&amp;sig=ACfU3U2S6oXxodelVkXqKmwUxsX6EynaoA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwic2IP7nsXqAhUSPXAKHQnGBo4Q6AEwBnoECA8QAQ#v=onepage&amp;q=PAC%E5%AD%A6%E4%B9%A0&amp;f=false</a></p>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h2><p>​        采用数学方法，研究学习算法的计算复杂性和所需信息量的大小，分析算法所需的时间和空间资源，判定学习对象的可学习性等所形成的理论。</p>
<h2 id="1-1-历史研究"><a href="#1-1-历史研究" class="headerlink" title="1.1 历史研究"></a>1.1 历史研究</h2><p>1967年，E. M. Gold，形式化语言研究 提出 极限辨识理论</p>
<blockquote>
<p>什么是正确的辨识(学习)的形式定义</p>
</blockquote>
<p>D. Angluin 探讨新的学习对象，提出 模式语言学习</p>
<blockquote>
<p>对学习对象的限制，获取某些有用的结果</p>
</blockquote>
<p>1984年，L. G. Valiant 提出 PAC模型（概率近似模型）</p>
<blockquote>
<p>反映了机器学习和人类学习的某些特点</p>
</blockquote>
<p>VC维数</p>
<blockquote>
<p>和可学习型以及所需样本数联系起来</p>
</blockquote>
<h2 id="2-PAC学习模型"><a href="#2-PAC学习模型" class="headerlink" title="2 PAC学习模型"></a>2 PAC学习模型</h2><ol>
<li>允许学习者有时失败</li>
<li>允许学习者在学习成功时可以是近似正确的</li>
</ol>
<p>PAC可学习性定义</p>
<blockquote>
<p>误差参数、可靠性参数</p>
<p>学习产生的假设和目标之间的误差不超过误差参数</p>
<p>超过误差参数属于失败，失败概率小于 可靠性参数</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>队列(循环)</title>
    <url>/jaheel.github.io/2020/10/19/%E9%98%9F%E5%88%97(%E5%BE%AA%E7%8E%AF)/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	QElemType *base;</span><br><span class="line">	<span class="keyword">int</span> front;</span><br><span class="line">	<span class="keyword">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.base = (QElemType *)<span class="built_in">malloc</span>(MAXQSIZE * <span class="keyword">sizeof</span>(QElemType));</span><br><span class="line">	<span class="keyword">if</span> (!Q.base)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.rear = Q.front=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CLearQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Q.base)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.rear = Q.front;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q.rear - Q.front+MAXQSIZE)%MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e = Q.base[Q.front];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((Q.rear+<span class="number">1</span>)%MAXQSIZE==Q.front)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	Q.base[Q.rear] = e;</span><br><span class="line">	Q.rear=(Q.rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e = Q.base[Q.front];</span><br><span class="line">	Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = Q.front;</span><br><span class="line">	<span class="keyword">while</span> (p != Q.rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Q.base[p]);</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	QElemType k, h, a, f;</span><br><span class="line">	SqQueue Q;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建一个空队列！\n&quot;</span>);</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;判断队列是否为空！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;QueueEmpty(Q)=%d\n&quot;</span>, QueueEmpty(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建队列的元素个数：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入%d个插入队列的元素的值：\n&quot;</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">		EnQueue(Q, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出队列元素的值：\n&quot;</span>);</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入插入队列的元素的值：&quot;</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; h;</span><br><span class="line">	EnQueue(Q, h);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出插入一个队列元素后队列元素的值：\n&quot;</span>);</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line">	DeQueue(Q, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出第1个删除的队头元素的值：%d\n&quot;</span>, a);</span><br><span class="line">	DeQueue(Q, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出第2个删除的队头元素的值：%d\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出两次删除队头元素后队列的元素值：&quot;</span>);</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line">	<span class="keyword">if</span> (!GetHead(Q, f))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输出队头元素的值：%d\n&quot;</span>, f);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出队列元素的个数：%d\n&quot;</span>, QueueLength(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将Q清为空队列！\n&quot;</span>);</span><br><span class="line">	CLearQueue(Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出队列元素的个数：%d\n&quot;</span>, QueueLength(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;判断队列是否为空！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;QueueEmpty(Q)=%d\n&quot;</span>, QueueEmpty(Q));</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>C++</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>队列（链式）</title>
    <url>/jaheel.github.io/2020/10/19/%E9%98%9F%E5%88%97%EF%BC%88%E9%93%BE%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p>教材：严版数据结构</p>
<p>代码如下：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QueuePtr front;<span class="comment">//队头指针</span></span><br><span class="line">	QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span> (!Q.front)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span><span class="comment">//销毁队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (Q.front) &#123;</span><br><span class="line">		Q.rear = Q.front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(Q.front);</span><br><span class="line">		Q.front = Q.rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CLearQueue</span><span class="params">(LinkQueue &amp;Q)</span><span class="comment">//清空队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p, q;</span><br><span class="line">	<span class="keyword">if</span> (!Q.front)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	p = Q.front-&gt;next;</span><br><span class="line">	Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	Q.rear = Q.front;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	p = Q.front-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		n++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = Q.front-&gt;next;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	p-&gt;data = e;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next = p;</span><br><span class="line">	Q.rear = p;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = Q.front-&gt;next;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	Q.front-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">		Q.rear = Q.front;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p = Q.front-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	QElemType k, h, a, f;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建一个空队列！\n&quot;</span>);</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;判断队列是否为空!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;QueueEmpty(Q)=%d\n&quot;</span>, QueueEmpty(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建队列的元素个数：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入%d个插入队列的元素的值：\n&quot;</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">		EnQueue(Q, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出队列元素的值：\n&quot;</span>);</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入插入队列的元素的值：&quot;</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; h;</span><br><span class="line">	EnQueue(Q, h);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入插入一个队列元素后队列元素的值：&quot;</span>);</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line">	DeQueue(Q, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入第1个删除的队头元素的值：%d\n&quot;</span>, a);</span><br><span class="line">	DeQueue(Q, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入第2个删除的队头元素的值：%d\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出两次删除队头元素后队列的元素值：&quot;</span>);</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line">	<span class="keyword">if</span> (!GetHead(Q, f))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输出队头元素的值：%d\n&quot;</span>, f);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出队列元素的个数：%d\n&quot;</span>, QueueLength(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将Q清为空队列！\n&quot;</span>);</span><br><span class="line">	CLearQueue(Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输出队列元素的个数：%d\n&quot;</span>, QueueLength(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;判断队列是否为空！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;QueueEmpty(Q)=%d\n&quot;</span>, QueueEmpty(Q));</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
        <tag>Algorithm</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>集成学习</title>
    <url>/jaheel.github.io/2020/10/19/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>集成学习：构建并结合多个学习器来完成学习任务（多分类器系统）</p>
<p>结构：先产生一组“个体学习器”(individual learner)，再用某种策略将它们结合起来</p>
<p>同质(homogeneous)</p>
<blockquote>
<p>“决策树集成”中全是决策树，“神经网络集成”中全是神经网络</p>
<p>基学习器(base learner) —&gt; 基学习算法(base learning algorithm)</p>
</blockquote>
<p>异质(heterogenous)</p>
<blockquote>
<p>个体学习器由不同学习算法组成：组件学习器(component learner)</p>
</blockquote>
<p>研究核心：如何产生并结合“好而不同”的个体学习器</p>
<p>分类：</p>
<ol>
<li><p>个体学习器间存在强依赖关系、必须串行生成的序列化方法</p>
<blockquote>
<p>Boosting</p>
</blockquote>
</li>
<li><p>个体学习器间不存在强依赖关系、可同时生成的并行化方法</p>
<blockquote>
<p>Bagging和“随机森林”(Random Forest)</p>
</blockquote>
</li>
</ol>
<h2 id="1-Boosting"><a href="#1-Boosting" class="headerlink" title="1 Boosting"></a>1 Boosting</h2><p>将弱学习器提升为强学习器的算法</p>
<p>代表算法：AdaBoost算法</p>
<h2 id="2-Bagging"><a href="#2-Bagging" class="headerlink" title="2 Bagging"></a>2 Bagging</h2><p>自助采样法(bootstrap sampling)</p>
<p>过程：给定m个样本的数据集，随机取一个再放回，重复m次，形成采样集；总共T个采样集，再基于采样集训练基学习器，再将这些基学习器结合。</p>
<p>样本扰动</p>
<h2 id="3-随机森林-RF"><a href="#3-随机森林-RF" class="headerlink" title="3 随机森林(RF)"></a>3 随机森林(RF)</h2><p>在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。</p>
<p>样本扰动+属性扰动</p>
<h2 id="4-结合策略"><a href="#4-结合策略" class="headerlink" title="4 结合策略"></a>4 结合策略</h2><ol>
<li><p>平均法averaging（回归问题）</p>
<blockquote>
<p>简单平均法(Simple averaging)</p>
<p>加权平均法(weighted averaging)</p>
</blockquote>
</li>
<li><p>投票法 voting（分类问题）</p>
<blockquote>
<p>绝对多数投票法(majority voting)：必须占一半以上</p>
<p>相对多数投票法(plurality voting)：最多票数即可</p>
<p>加权投票法(weighted voting)</p>
</blockquote>
</li>
<li><p>学习法</p>
<blockquote>
<p>Stacking</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Csharp Structure</title>
    <url>/jaheel.github.io/2020/10/19/Csharp%20Structure/</url>
    <content><![CDATA[<h1 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h1><p>C# Dictionary class is a generic collection of keys and values pair of data.</p>
<p>Defined in the System.Collections.Generic namespace is a generic class and can store any data types in a form of keys and values. Each key must be unique in the collection.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br></pre></td></tr></table></figure>

<h2 id="1-Add-elements-to-a-C-Dictionary"><a href="#1-Add-elements-to-a-C-Dictionary" class="headerlink" title="1 Add elements to a C# Dictionary"></a>1 Add elements to a C# Dictionary</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; EmployeeList=<span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,stirng&gt;();</span><br><span class="line"><span class="comment">//Add items to the dictionary both keys and values are string types</span></span><br><span class="line">EmployeeList.Add(<span class="string">&quot;Mahesh Chand&quot;</span>, <span class="string">&quot;Programmer&quot;</span>);    </span><br><span class="line">EmployeeList.Add(<span class="string">&quot;Praveen Kumar&quot;</span>, <span class="string">&quot;Project Manager&quot;</span>);    </span><br><span class="line">EmployeeList.Add(<span class="string">&quot;Raj Kumar&quot;</span>, <span class="string">&quot;Architect&quot;</span>);    </span><br><span class="line">EmployeeList.Add(<span class="string">&quot;Nipun Tomar&quot;</span>, <span class="string">&quot;Asst. Project Manager&quot;</span>);    </span><br><span class="line">EmployeeList.Add(<span class="string">&quot;Dinesh Beniwal&quot;</span>, <span class="string">&quot;Manager&quot;</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>,Int16&gt; AuthorList=<span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,Int16&gt;();</span><br><span class="line"><span class="comment">//Add items to the dictionary where the key type is string and value type is short integer</span></span><br><span class="line">AuthorList.Add(<span class="string">&quot;Mahesh Chand&quot;</span>, <span class="number">35</span>);    </span><br><span class="line">AuthorList.Add(<span class="string">&quot;Mike Gold&quot;</span>, <span class="number">25</span>);    </span><br><span class="line">AuthorList.Add(<span class="string">&quot;Praveen Kumar&quot;</span>, <span class="number">29</span>);    </span><br><span class="line">AuthorList.Add(<span class="string">&quot;Raj Beniwal&quot;</span>, <span class="number">21</span>);    </span><br><span class="line">AuthorList.Add(<span class="string">&quot;Dinesh Beniwal&quot;</span>, <span class="number">84</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//We can also limit the size of a dictionary.The following code shows the limit is 3.</span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">float</span>&gt; PriceList = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">float</span>&gt;(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-Retrieve-elements-from-a-C-Dictionary"><a href="#2-Retrieve-elements-from-a-C-Dictionary" class="headerlink" title="2  Retrieve elements from a C# Dictionary"></a>2  Retrieve elements from a C# Dictionary</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">string</span>,Int16&gt; author <span class="keyword">in</span> AuthorList)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Key:&#123;0&#125;, Value&#123;1&#125;&quot;</span>,author.Key,author.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="3-C-Dictionary-Properties"><a href="#3-C-Dictionary-Properties" class="headerlink" title="3 C# Dictionary Properties"></a>3 C# Dictionary Properties</h2><p>Count, Keys and Values.</p>
<h2 id="4-Get-number-of-elements-in-a-C-Dictionary"><a href="#4-Get-number-of-elements-in-a-C-Dictionary" class="headerlink" title="4 Get number of elements in a C# Dictionary"></a>4 Get number of elements in a C# Dictionary</h2><p>The Count property gets the number of key/value pairs in a Dictionary.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;Count: &#123;0&#125;&quot;</span>, AuthorList.Count);</span><br></pre></td></tr></table></figure>

<h2 id="5-Get-a-Dictionary-item"><a href="#5-Get-a-Dictionary-item" class="headerlink" title="5 Get a Dictionary item"></a>5 Get a Dictionary item</h2><p>The Item property gets and sets the value associated with the specified key.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set Item value    </span></span><br><span class="line">AuthorList[<span class="string">&quot;Mahesh Chand&quot;</span>] = <span class="number">20</span>;    </span><br><span class="line"><span class="comment">// Get Item value    </span></span><br><span class="line">Int16 age = Convert.ToInt16(AuthorList[<span class="string">&quot;Mahesh Chand&quot;</span>]); </span><br></pre></td></tr></table></figure>

<h2 id="6-Get-the-collection-of-keys-of-C-Dictionary"><a href="#6-Get-the-collection-of-keys-of-C-Dictionary" class="headerlink" title="6 Get the collection of keys of C# Dictionary"></a>6 Get the collection of keys of C# Dictionary</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get and display keys    </span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, Int16&gt;.KeyCollection keys = AuthorList.Keys;    </span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> key <span class="keyword">in</span> keys)    </span><br><span class="line">&#123;    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Key: &#123;0&#125;&quot;</span>, key);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Get-the-collection-of-values-of-a-C-Dictionary"><a href="#7-Get-the-collection-of-values-of-a-C-Dictionary" class="headerlink" title="7 Get the collection of values of a C# Dictionary"></a>7 Get the collection of values of a C# Dictionary</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get and display values    </span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, Int16&gt;.ValueCollection values = AuthorList.Values;    </span><br><span class="line"><span class="keyword">foreach</span> (Int16 val <span class="keyword">in</span> values)    </span><br><span class="line">&#123;    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Value: &#123;0&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-C-Dictionary-Methods"><a href="#8-C-Dictionary-Methods" class="headerlink" title="8 C# Dictionary Methods"></a>8 C# Dictionary Methods</h2><p>The Dictionary class is a generic collection and provides all common methods to <strong>add, remove, find and replace items</strong> in the collection. </p>
<h2 id="9-Add-Items"><a href="#9-Add-Items" class="headerlink" title="9 Add Items"></a>9 Add Items</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">string</span>, Int16&gt; AuthorList = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Int16&gt;();    </span><br><span class="line">AuthorList.Add(<span class="string">&quot;Mahesh Chand&quot;</span>, <span class="number">35</span>);</span><br></pre></td></tr></table></figure>

<h2 id="10-Remove-elements-from-a-C-dictionary"><a href="#10-Remove-elements-from-a-C-dictionary" class="headerlink" title="10 Remove elements from a C# dictionary"></a>10 Remove elements from a C# dictionary</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Remove item with key = &#x27;Mahesh Chand&#x27;    </span></span><br><span class="line">AuthorList.Remove(<span class="string">&quot;Mahesh Chand&quot;</span>);</span><br><span class="line"><span class="comment">// Remove all items    </span></span><br><span class="line">AuthorList.Clear();</span><br></pre></td></tr></table></figure>

<h2 id="11-Find-a-key-in-a-Dictionary"><a href="#11-Find-a-key-in-a-Dictionary" class="headerlink" title="11 Find a key in a Dictionary"></a>11 Find a key in a Dictionary</h2><p>The ContainsKey method checks if a key is already exists in the dictionary. </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!AuthorList.ContainsKey(<span class="string">&quot;Mahesh Chand&quot;</span>))    </span><br><span class="line">&#123;    </span><br><span class="line">    AuthorList[<span class="string">&quot;Mahesh Chand&quot;</span>] = <span class="number">20</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-Find-a-Value-in-a-Dictionary"><a href="#12-Find-a-Value-in-a-Dictionary" class="headerlink" title="12 Find a Value in a Dictionary"></a>12 Find a Value in a Dictionary</h2><p>The ContainsValue method checks if a value is already exists in the dictionary. </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!AuthorList.ContainsValue(<span class="number">9</span>))    </span><br><span class="line">&#123;    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Item found&quot;</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p> Queue represents a first-in, first-out (FIFO) collection of objects.</p>
<h2 id="1-Queue-Constructors"><a href="#1-Queue-Constructors" class="headerlink" title="1 Queue Constructors"></a>1 Queue Constructors</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Queue&lt;T&gt; Constructor</span></span><br><span class="line">Queue&lt;<span class="built_in">string</span>&gt; queue = newQueue&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Queue&lt;T&gt; Constructor (IEnumerable&lt;T&gt;)</span></span><br><span class="line"><span class="built_in">string</span>[] courses = &#123; <span class="string">&quot;MCA&quot;</span>,<span class="string">&quot;MBA&quot;</span>, <span class="string">&quot;BCA&quot;</span>,<span class="string">&quot;BBA&quot;</span>, <span class="string">&quot;BTech&quot;</span>,<span class="string">&quot;MTech&quot;</span> &#125;;  </span><br><span class="line">Queue&lt;<span class="built_in">string</span>&gt; queue = newQueue&lt;<span class="built_in">string</span>&gt;(courses); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Queue&lt;T&gt; Constructor (Int32) </span></span><br><span class="line">Queue&lt;<span class="built_in">string</span>&gt; queue = newQueue&lt;<span class="built_in">string</span>&gt;(<span class="number">4</span>); </span><br></pre></td></tr></table></figure>

<h2 id="2-Queue-Count-Property"><a href="#2-Queue-Count-Property" class="headerlink" title="2 Queue.Count Property"></a>2 Queue.Count Property</h2><p>The Count property gets the number of elements of Queue&lt;T&gt;.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Queue</span> &#123;  </span><br><span class="line">    classProgram &#123;  </span><br><span class="line">        <span class="function">staticvoid <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;  </span><br><span class="line">            <span class="built_in">string</span>[] courses = &#123;  </span><br><span class="line">                <span class="string">&quot;MCA&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;MBA&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;BCA&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;BBA&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;BTech&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;MTech&quot;</span>  </span><br><span class="line">            &#125;;  </span><br><span class="line">            Queue &lt; <span class="built_in">string</span> &gt; queue1 = newQueue &lt; <span class="built_in">string</span> &gt; ();  </span><br><span class="line">            Queue &lt; <span class="built_in">string</span> &gt; queue2 = newQueue &lt; <span class="built_in">string</span> &gt; (courses);  </span><br><span class="line">            Queue &lt; <span class="built_in">string</span> &gt; queue3 = newQueue &lt; <span class="built_in">string</span> &gt; (<span class="number">4</span>);  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Number of elements in queue1:&quot;</span> + queue1.Count());  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Number of elements in queue2:&quot;</span> + queue2.Count());  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Number of elements in queue3:&quot;</span> + queue3.Count());  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: 0 6 0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Queue-Enqueue"><a href="#3-Queue-Enqueue" class="headerlink" title="3 Queue.Enqueue()"></a>3 Queue.Enqueue()</h2><p>The Queue.Enqueue method adds an object to the end of the Queue<T>.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Queue</span> &#123;  </span><br><span class="line">    classProgram &#123;  </span><br><span class="line">        <span class="function">staticvoid <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;  </span><br><span class="line">            Queue &lt; <span class="built_in">string</span> &gt; queue1 = newQueue &lt; <span class="built_in">string</span> &gt; ();  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;MCA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;MBA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;BCA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;BBA&quot;</span>);  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The elements in the queue are:&quot;</span>);  </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">string</span> s <span class="keyword">in</span> queue1) &#123;  </span><br><span class="line">                Console.WriteLine(s);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="4-Queue-Dequeue"><a href="#4-Queue-Dequeue" class="headerlink" title="4 Queue.Dequeue()"></a>4 Queue.Dequeue()</h2><p>Removes and returns the object at the beginning of the Queue<T>.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Queue</span> &#123;  </span><br><span class="line">    classProgram &#123;  </span><br><span class="line">        <span class="function">staticvoid <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;  </span><br><span class="line">            Queue &lt; <span class="built_in">string</span> &gt; queue1 = newQueue &lt; <span class="built_in">string</span> &gt; ();  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;MCA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;MBA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;BCA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;BBA&quot;</span>);  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The elements in the queue are:&quot;</span>);  </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">string</span> s <span class="keyword">in</span> queue1) &#123;  </span><br><span class="line">                Console.WriteLine(s);  </span><br><span class="line">            &#125;  </span><br><span class="line">            queue1.Dequeue(); <span class="comment">//Removes the first element that enter in the queue here the first element is MCA  </span></span><br><span class="line">            queue1.Dequeue(); <span class="comment">//Removes MBA  </span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;After removal the elements in the queue are:&quot;</span>);  </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">string</span> s <span class="keyword">in</span> queue1) &#123;  </span><br><span class="line">                Console.WriteLine(s);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="5-Queue-contain"><a href="#5-Queue-contain" class="headerlink" title="5 Queue.contain()"></a>5 Queue.contain()</h2><p>Determines whether an element is in the Queue<T>.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Queue</span> &#123;  </span><br><span class="line">    classProgram &#123;  </span><br><span class="line">        <span class="function">staticvoid <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;  </span><br><span class="line">            Queue &lt; <span class="built_in">string</span> &gt; queue1 = newQueue &lt; <span class="built_in">string</span> &gt; ();  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;MCA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;MBA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;BCA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;BBA&quot;</span>);  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The elements in the queue are:&quot;</span>);  </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">string</span> s <span class="keyword">in</span> queue1) &#123;  </span><br><span class="line">                Console.WriteLine(s);  </span><br><span class="line">            &#125;  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The element MCA is contain in the queue:&quot;</span> + queue1.Contains(<span class="string">&quot;MCA&quot;</span>));  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The element BCA is contain in the queue:&quot;</span> + queue1.Contains(<span class="string">&quot;BCA&quot;</span>));  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The element MTech is contain in the queue:&quot;</span> + queue1.Contains(<span class="string">&quot;MTech&quot;</span>));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="6-Queue-Clear"><a href="#6-Queue-Clear" class="headerlink" title="6 Queue.Clear()"></a>6 Queue.Clear()</h2><p>Removes all objects from the Queue<T>.</p>
<h2 id="7-Queue-Peek"><a href="#7-Queue-Peek" class="headerlink" title="7 Queue.Peek()"></a>7 Queue.Peek()</h2><p>Returns the object at the beginning of the Queue<T> without removing it.</p>
<h2 id="8-Queue-ToArray"><a href="#8-Queue-ToArray" class="headerlink" title="8 Queue.ToArray()"></a>8 Queue.ToArray()</h2><p>Copies the Queue<T> elements to a new array.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Queue</span> &#123;  </span><br><span class="line">    classProgram &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;  </span><br><span class="line">            Queue &lt; <span class="built_in">string</span> &gt; queue1 = newQueue &lt; <span class="built_in">string</span> &gt; ();  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;MCA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;MBA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;BCA&quot;</span>);  </span><br><span class="line">            queue1.Enqueue(<span class="string">&quot;BBA&quot;</span>);  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The queue elements are:&quot;</span>);  </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">string</span> s <span class="keyword">in</span> queue1) &#123;  </span><br><span class="line">                Console.WriteLine(s);  </span><br><span class="line">            &#125;  </span><br><span class="line">            Queue &lt; <span class="built_in">string</span> &gt; queue2 = newQueue &lt; <span class="built_in">string</span> &gt; (queue1.ToArray());  </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\nContents of the copy&quot;</span>);  </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">string</span> n <span class="keyword">in</span> queue2) &#123;  </span><br><span class="line">                Console.WriteLine(n);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>A stack is a LIFO (last in first out) data structure.</p>
<h2 id="1-Stack-Constructors"><a href="#1-Stack-Constructors" class="headerlink" title="1 Stack Constructors"></a>1 Stack Constructors</h2><p>Stack<T>() Constructor</p>
<p>Stack<T>(IEnumerable<T>)</p>
<p>Stack<T>(Int32)</p>
<h2 id="2-Stack-Count-Property"><a href="#2-Stack-Count-Property" class="headerlink" title="2 Stack.Count Property"></a>2 Stack.Count Property</h2><p>he Count property of the Stack class returns the number of elements in a stack. </p>
<h2 id="3-Stack-Push"><a href="#3-Stack-Push" class="headerlink" title="3 Stack.Push()"></a>3 Stack.Push()</h2><p>The Push() method is used to add a (push) element to the stack.</p>
<h2 id="4-Stack-Pop"><a href="#4-Stack-Pop" class="headerlink" title="4 Stack.Pop()"></a>4 Stack.Pop()</h2><p>The Pop() method is used to remove elements from a stack. The Pop() method removes the top most item from the stack.</p>
<h2 id="5-Stack-Peek"><a href="#5-Stack-Peek" class="headerlink" title="5 Stack.Peek()"></a>5 Stack.Peek()</h2><p>The Peek() method returns the topmost element of a Stack<T> without removing it. </p>
<h2 id="6-Stack-Clear"><a href="#6-Stack-Clear" class="headerlink" title="6 Stack.Clear()"></a>6 Stack.Clear()</h2><p>The Clear() method of Stack<T> removes all elements from a stack. </p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>The C# List<T> class in .NET represents a collection of strongly typed objects that can be accessed by index. </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic; </span><br></pre></td></tr></table></figure>

<h2 id="1-List-Constructors"><a href="#1-List-Constructors" class="headerlink" title="1 List Constructors"></a>1 List Constructors</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List with default capacity  </span></span><br><span class="line">List&lt;Int16&gt; list = <span class="keyword">new</span> List&lt;Int16&gt;();  </span><br><span class="line"><span class="comment">// List with capacity = 5  </span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; authors = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;(<span class="number">5</span>);  </span><br><span class="line"><span class="built_in">string</span>[] animals = &#123; <span class="string">&quot;Cow&quot;</span>, <span class="string">&quot;Camel&quot;</span>, <span class="string">&quot;Elephant&quot;</span> &#125;;  </span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; animalsList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;(animals);  </span><br></pre></td></tr></table></figure>

<h2 id="2-List-Add"><a href="#2-List-Add" class="headerlink" title="2 List.Add()"></a>2 List.Add()</h2><p>The Add method adds an element to a List.</p>
<h2 id="3-List-Properties"><a href="#3-List-Properties" class="headerlink" title="3 List Properties"></a>3 List Properties</h2><ul>
<li>Capacity – Number of elements List<T> can contain. The default capacity of a List<T> is 0.</li>
<li>Count – Number of elements in List<T>.</li>
</ul>
<h2 id="4-List-Insert"><a href="#4-List-Insert" class="headerlink" title="4 List.Insert()"></a>4 List.Insert()</h2><p>The Insert method of List class inserts an object at a given position. The first parameter of the method is the 0th based index in the List.</p>
<p>The InsertRange method can insert a collection at the given position. </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">authors.Insert(<span class="number">3</span>, <span class="string">&quot;Bill Author&quot;</span>);  </span><br><span class="line"><span class="comment">// Collection of new authors  </span></span><br><span class="line"><span class="built_in">string</span>[] newAuthors = &#123; <span class="string">&quot;New Author1&quot;</span>, <span class="string">&quot;New Author2&quot;</span>, <span class="string">&quot;New Author3&quot;</span> &#125;;  </span><br><span class="line"><span class="comment">// Insert array at position 2  </span></span><br><span class="line">authors.InsertRange(<span class="number">2</span>, newAuthors);  </span><br></pre></td></tr></table></figure>

<h2 id="5-List-Remove"><a href="#5-List-Remove" class="headerlink" title="5 List.Remove()"></a>5 List.Remove()</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//he Remove method removes the first occurrence of the given item in the List.</span></span><br><span class="line"><span class="comment">// Remove an item  </span></span><br><span class="line">authors.Remove(<span class="string">&quot;New Author1&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 3rd item  </span></span><br><span class="line">authors.RemoveAt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//The RemoveRange method removes a list of items from the starting index to the number of items. </span></span><br><span class="line"><span class="comment">// Remove a range  </span></span><br><span class="line">authors.RemoveRange(<span class="number">3</span>, <span class="number">2</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove all items  </span></span><br><span class="line">authors.Clear(); </span><br></pre></td></tr></table></figure>

<h2 id="6-List-IndexOf"><a href="#6-List-IndexOf" class="headerlink" title="6 List.IndexOf()"></a>6 List.IndexOf()</h2><p>The IndexOf method finds an item in a List. The IndexOf method returns -1 if there are no items found in the List. </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> idx = authors.IndexOf(<span class="string">&quot;Naveen Sharma&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span> (idx &gt; <span class="number">0</span>)  </span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Item index in List is: <span class="subst">&#123;idx&#125;</span>&quot;</span>);  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">Console.WriteLine(<span class="string">&quot;Item not found&quot;</span>);  </span><br></pre></td></tr></table></figure>

<h2 id="7-List-Sort"><a href="#7-List-Sort" class="headerlink" title="7 List.Sort()"></a>7 List.Sort()</h2><p>The Sort method of List<T> sorts all items of the List using the QuickSort algorithm. </p>
<h2 id="8-List-Reverse"><a href="#8-List-Reverse" class="headerlink" title="8 List.Reverse()"></a>8 List.Reverse()</h2><p>The Reverse method of List<T> reverses the order all items in in the List. </p>
<h2 id="9-List-BinarySearch"><a href="#9-List-BinarySearch" class="headerlink" title="9 List.BinarySearch()"></a>9 List.BinarySearch()</h2><p>The BinarySearch method of List<T> searches a sorted list and returns the zero-based index of the found item. The List<T> must be sorted before this method can be used. </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> bs = authors.BinarySearch(<span class="string">&quot;Mahesh Chand&quot;</span>);  </span><br></pre></td></tr></table></figure>

<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>The Hashtable in C# is a collection that stores (Keys, Values) pairs.</p>
<p>The Keys are used to find the storage location.</p>
<p>The Base Class libraries offers a Hashtable Class that is defined in the <strong>System.Collections</strong> namespace.</p>
<h2 id="1-HashTable-Constructors"><a href="#1-HashTable-Constructors" class="headerlink" title="1 HashTable Constructors"></a>1 HashTable Constructors</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Hashtable HT = <span class="keyword">new</span> Hashtable();</span><br><span class="line">Hashtable HT = <span class="keyword">new</span> Hashtable(<span class="number">100</span>); </span><br></pre></td></tr></table></figure>

<h2 id="2-Properties-of-Hashtable"><a href="#2-Properties-of-Hashtable" class="headerlink" title="2 Properties of Hashtable"></a>2 Properties of Hashtable</h2><ul>
<li>Comparer: Gets or Sets the IComparer to use for the Hash Table.</li>
<li>Count: Gets the number of key/value pairs contained in the hash table.</li>
<li>IsReadOnly: Get a value indicating whether the hash table is read-only.</li>
<li>Item: Gets or Sets the value associated with the specified Key.</li>
<li>Keys: Gets an ICollection containing the keys in the hash table.</li>
<li>Values: Gets an ICollection containing the values in the hash table.</li>
</ul>
<h2 id="3-Methods-of-HashTable"><a href="#3-Methods-of-HashTable" class="headerlink" title="3 Methods of HashTable"></a>3 Methods of HashTable</h2><ul>
<li>Add: Adds an element with the specified key and value in the hash table.</li>
<li>Clear: Removes all the elements in the hash table.</li>
<li>ContainsKey: Determined whether the hash table contains a specified key or not.</li>
<li>ContainsValue: Determined whether the hash table contains a specified value or not.</li>
</ul>
<h1 id="StringCollection"><a href="#StringCollection" class="headerlink" title="StringCollection"></a>StringCollection</h1><p>StringCollection class is a new addition to the .NET Framework class library that represents a collection of strings.</p>
<p>StringCollection class defined in the <strong>System.Collections.Specialized</strong> namespace represents a collection of strings and provides functionality to manage the collection.</p>
<h2 id="1-StringCollection-Constructor"><a href="#1-StringCollection-Constructor" class="headerlink" title="1 StringCollection Constructor"></a>1 StringCollection Constructor</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Specialized</span><br><span class="line"></span><br><span class="line">StringCollection authorNames = <span class="keyword">new</span> StringCollection();</span><br></pre></td></tr></table></figure>

<h2 id="2-Adding-Strings"><a href="#2-Adding-Strings" class="headerlink" title="2 Adding Strings"></a>2 Adding Strings</h2><ul>
<li>Add</li>
<li>AddRange</li>
<li>Insert</li>
</ul>
<p>Add method is used to add string to a StringCollection at the end of the collection. </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add string using Add method  </span></span><br><span class="line">authorNames.Add(<span class="string">&quot;Mahesh Chand&quot;</span>);  </span><br><span class="line">authorNames.Add(<span class="string">&quot;Mike Gold&quot;</span>);  </span><br><span class="line">authorNames.Add(<span class="string">&quot;Praveen Kumar&quot;</span>);  </span><br><span class="line">authorNames.Add(<span class="string">&quot;Raj Beniwal&quot;</span>);  </span><br></pre></td></tr></table></figure>

<p>AddRange method is used to add an array of strings to a StringCollection at the end of the collection. </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add an array of string using AddRange  </span></span><br><span class="line"><span class="built_in">string</span>[] names = <span class="keyword">new</span> <span class="built_in">string</span>[]&#123;<span class="string">&quot;Mahesh Chand&quot;</span>, <span class="string">&quot;Mike Gold&quot;</span>, <span class="string">&quot;Praveen Kumar&quot;</span>, <span class="string">&quot;Raj Beniwal&quot;</span>&#125;;  </span><br><span class="line">authorNames.AddRange(names); </span><br></pre></td></tr></table></figure>

<p>Insert method is used to insert a string at the specified location of a StringCollection.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert an string at a specified index  </span></span><br><span class="line">authorNames.Insert(<span class="number">5</span>, <span class="string">&quot;New Author&quot;</span>);  </span><br></pre></td></tr></table></figure>

<h2 id="3-Accessing-Strings"><a href="#3-Accessing-Strings" class="headerlink" title="3 Accessing Strings"></a>3 Accessing Strings</h2><p>The foreach loop statement in C# is used to iterate through a collection of objects such as integer or string.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">StringCollection authorNames = <span class="keyword">new</span> StringCollection();  </span><br><span class="line"><span class="built_in">string</span>[] names = <span class="keyword">new</span> <span class="built_in">string</span>[]&#123;<span class="string">&quot;Mahesh Chand&quot;</span>, <span class="string">&quot;Mike Gold&quot;</span>, <span class="string">&quot;Praveen Kumar&quot;</span>, <span class="string">&quot;Raj Beniwal&quot;</span>&#125;;  </span><br><span class="line">authorNames.AddRange(names);  </span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> authorNames)  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(name);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="4-Removing-Strings"><a href="#4-Removing-Strings" class="headerlink" title="4 Removing Strings"></a>4 Removing Strings</h2><ul>
<li>Clear</li>
<li>Remove</li>
<li>RemoveAt</li>
</ul>
<p>Clear method removes all items from a StringCollection.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">authorNames.Clear(); </span><br></pre></td></tr></table></figure>

<p>Remove method removes the first occurrence of a given string from the string collection.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">authorNames.Remove(<span class="string">&quot;Mike Gold&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>RemoveAt method removes a string specified at the given location from the string collection.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">authorNames.RemoveAt(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-Find-String"><a href="#5-Find-String" class="headerlink" title="5 Find String"></a>5 Find String</h2><p>IndexOf method searches for the specified string and returns the zero-based index of the first occurrence within the StringCollection.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> authorLocation = authorNames.IndexOf(<span class="string">&quot;Mike Gold&quot;</span>);  </span><br><span class="line">Console.WriteLine(<span class="string">&quot;Position of Mike Gold is &quot;</span> + authorLocation.ToString());</span><br></pre></td></tr></table></figure>

<p>Contains method returns true if a string is found in a StringCollection.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (authorNames.Contains(<span class="string">&quot;Mike Gold&quot;</span>))  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Mike Gold is at position: &quot;</span> + authorNames.IndexOf(<span class="string">&quot;Mike Gold&quot;</span>));  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="6-Copy-Strings"><a href="#6-Copy-Strings" class="headerlink" title="6 Copy Strings"></a>6 Copy Strings</h2><p>CopyTo method of StringCollection is used to copy items from a StringCollection to an array.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy Collection to new Array  </span></span><br><span class="line"><span class="built_in">string</span>[] newAuthorList = <span class="keyword">new</span> <span class="built_in">string</span>[authorNames.Count];  </span><br><span class="line">authorNames.CopyTo(newAuthorList, <span class="number">0</span>);  </span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> newAuthorList)  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(name);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="7-Count-Strings"><a href="#7-Count-Strings" class="headerlink" title="7 Count Strings"></a>7 Count Strings</h2><p>Count property returns total number of items in in a StringCollection.</p>
<h2 id="8-Getting-Items"><a href="#8-Getting-Items" class="headerlink" title="8 Getting Items"></a>8 Getting Items</h2><p>ArrayCollection is a collection. That means, you can access its items by using an index.</p>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>C# HashSet is an unordered collection of the unique elements.</p>
<p><strong>System.Collections.Generic</strong></p>
<h2 id="1-HashSet-Constructor"><a href="#1-HashSet-Constructor" class="headerlink" title="1 HashSet Constructor"></a>1 HashSet Constructor</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">HashSet &lt; <span class="built_in">string</span> &gt; names = <span class="keyword">new</span> HashSet &lt; <span class="built_in">string</span> &gt; &#123;  </span><br><span class="line">                <span class="string">&quot;Rajeev&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;Akash&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;Amit&quot;</span>  </span><br><span class="line">            &#125;; </span><br></pre></td></tr></table></figure>

<h2 id="2-HashSet-Add"><a href="#2-HashSet-Add" class="headerlink" title="2 HashSet.Add()"></a>2 HashSet.Add()</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">names.Add(<span class="string">&quot;Rajeev&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-HashSet-UnionWith"><a href="#3-HashSet-UnionWith" class="headerlink" title="3 HashSet.UnionWith()"></a>3 HashSet.UnionWith()</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">HashSet &lt; <span class="built_in">string</span> &gt; names = <span class="keyword">new</span> HashSet &lt; <span class="built_in">string</span> &gt; &#123;  </span><br><span class="line">                <span class="string">&quot;Rajeev&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;Akash&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;Amit&quot;</span>  </span><br><span class="line">            &#125;;  </span><br><span class="line">            HashSet &lt; <span class="built_in">string</span> &gt; names1 = <span class="keyword">new</span> HashSet &lt; <span class="built_in">string</span> &gt; &#123;  </span><br><span class="line">                <span class="string">&quot;Rajeev&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;Akash&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;Amit&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;Deepak&quot;</span>,  </span><br><span class="line">                <span class="string">&quot;Mohit&quot;</span>  </span><br><span class="line">            &#125;;  </span><br><span class="line">            names.UnionWith(names1);</span><br></pre></td></tr></table></figure>

<h2 id="4-HashSet-IntersectWith"><a href="#4-HashSet-IntersectWith" class="headerlink" title="4 HashSet.IntersectWith()"></a>4 HashSet.IntersectWith()</h2><p>This method combines the elements that are common to both the collections.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">names.IntersectWith(names1);</span><br></pre></td></tr></table></figure>

<h2 id="5-HashSet-ExceptWith"><a href="#5-HashSet-ExceptWith" class="headerlink" title="5 HashSet.ExceptWith()"></a>5 HashSet.ExceptWith()</h2><p>This method removes all the elements that are present in the other collections from the collection on which it is called.</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>Linked List is a linear data structure which consists of a group of nodes in a sequence. Each node contains two parts.</p>
<ul>
<li>Data− Each node of a linked list can store a data.</li>
<li>Address − Each node of a linked list contains an address to the next node, called “Next”.</li>
</ul>
<h2 id="1-Types-of-Linked-List"><a href="#1-Types-of-Linked-List" class="headerlink" title="1 Types of Linked List"></a>1 Types of Linked List</h2><ul>
<li><p><strong>Singly Linked List:</strong> Singly linked lists contain nodes which have a data part and an address part, i.e., Next, which points to the next node in the sequence of nodes. The next pointer of the last node will point to null.</p>
<p><img src="https://www.c-sharpcorner.com/article/linked-list-implementation-in-c-sharp/Images/LL_2.png" alt="img"></p>
</li>
<li><p><strong>Doubly Linked List:</strong> In a doubly linked list, each node contains two links - the first link points to the previous node and the next link points to the next node in the sequence.The prev pointer of the first node and next pointer of the last node will point to null.<br><img src="https://www.c-sharpcorner.com/article/linked-list-implementation-in-c-sharp/Images/LL_4.png" alt="img"></p>
</li>
<li><p><strong>Circular Linked List:</strong> In the circular linked list, the next of the last node will point to the first node, thus forming a circular chain.</p>
<p><img src="https://www.c-sharpcorner.com/article/linked-list-implementation-in-c-sharp/Images/LL3.png" alt="img"></p>
</li>
<li><p><strong>Doubly Circular Linked List:</strong> In this type of linked list, the next of the last node will point to the first node and the previous pointer of the first node will point to the last node.<br><img src="https://www.c-sharpcorner.com/article/linked-list-implementation-in-c-sharp/Images/DoublyCircular.png" alt="img"></p>
</li>
</ul>
<h2 id="2-Creating-a-Linked-List"><a href="#2-Creating-a-Linked-List" class="headerlink" title="2 Creating a Linked List"></a>2 Creating a Linked List</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Singly linked list</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Node</span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">int</span> data;</span><br><span class="line">    <span class="keyword">internal</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="built_in">int</span> d</span>)</span>&#123;</span><br><span class="line">        data=d;</span><br><span class="line">        next=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Doubly Linked List</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DNode</span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">int</span> data;</span><br><span class="line">    <span class="keyword">internal</span> DNode prev;</span><br><span class="line">    <span class="keyword">internal</span> DNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DNode</span>(<span class="params"><span class="built_in">int</span> d</span>)</span>&#123;</span><br><span class="line">        data=d;</span><br><span class="line">        prev=<span class="literal">null</span>;</span><br><span class="line">        next=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">SingleLinkedList</span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> Node head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DoubleLinkedList</span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> DNode head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Csharp</category>
      </categories>
      <tags>
        <tag>Csharp</tag>
        <tag>code</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库知识点汇总</title>
    <url>/jaheel.github.io/2020/10/19/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="1-数据库基础"><a href="#1-数据库基础" class="headerlink" title="1 数据库基础"></a>1 数据库基础</h1><h2 id="1-1-数据库简介"><a href="#1-1-数据库简介" class="headerlink" title="1.1 数据库简介"></a>1.1 数据库简介</h2><p>数据管理的有效技术，是由一批数据构成的有序集合，数据保存在结构化的数据表里。</p>
<ol>
<li>数据库：用于存储数据的地方</li>
<li>数据库管理系统：用于管理数据库的软件</li>
<li>数据库应用程序：为了提高数据库系统的处理能力所使用的管理数据库库的软件补充</li>
</ol>
<p>数据库管理系统(Database Management System, DBMS)</p>
<p>结构化查询语言(Structured Query Language)</p>
<h2 id="1-2-存储结构"><a href="#1-2-存储结构" class="headerlink" title="1.2 存储结构"></a>1.2 存储结构</h2><p>指数据库中的物理数据和逻辑数据的表示形式、物理数据和逻辑数据之间关系映射方式的描述。</p>
<p>物理数据和逻辑数据之间的转换通过数据库管理系统实现。</p>
<h3 id="1-2-1-物理数据"><a href="#1-2-1-物理数据" class="headerlink" title="1.2.1 物理数据"></a>1.2.1 物理数据</h3><p>数据在存储设备上的存储方式，实际存放在存储设备上的数据（物理记录）</p>
<p>有序存储、无序存储</p>
<p>单位：</p>
<blockquote>
<p>bit</p>
<p>byte</p>
<p>word：若干byte组成一个word（例如计算机字长8位、16位、32位等）</p>
<p>block：内存储器、外存储器交换信息的最小单位（物理块、物理记录）（256字节、512字节、1024字节等）</p>
<p>volume：一台输入输出设备所能装载的全部有用信息（卷）</p>
<p>unordered：数据记录按照插入的顺序进行存储</p>
</blockquote>
<h3 id="1-2-2-逻辑数据"><a href="#1-2-2-逻辑数据" class="headerlink" title="1.2.2 逻辑数据"></a>1.2.2 逻辑数据</h3><p>用户或程序员用于操作的数据形式，（逻辑记录）</p>
<ol>
<li><p>客观现实世界术语：</p>
<ul>
<li><p>实体(entity)</p>
</li>
<li><p>实体集(entities)</p>
<blockquote>
<p>特性完全相同的同类实体的集合</p>
</blockquote>
</li>
<li><p>属性(attribute)</p>
<blockquote>
<p>实体的特性成为属性</p>
</blockquote>
</li>
<li><p>标识符(identifier)</p>
<blockquote>
<p>能够唯一地标识每个实体地属性或属性集</p>
</blockquote>
</li>
</ul>
</li>
<li><p>关系型数据库管理系统：</p>
<ul>
<li><p>数据项(data item)：也称为字段(field)</p>
<blockquote>
<p>标记实体属性地可以命名的最小信息单位</p>
</blockquote>
</li>
<li><p>元组(tuple)</p>
<blockquote>
<p> 也成为记录(record)，数据项的集合称为元组</p>
</blockquote>
</li>
<li><p>关系(relation)</p>
<blockquote>
<p>同一类元组所在的集合称为关系</p>
</blockquote>
</li>
<li><p>键码(key)</p>
<blockquote>
<p>能够唯一地标识关系中每个元组地数据项或数据项的组合称为关系的键码</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h2 id="1-3-SQL语言"><a href="#1-3-SQL语言" class="headerlink" title="1.3 SQL语言"></a>1.3 SQL语言</h2><ol>
<li>数据定义语言(DDL)：DROP、CREATE、ALTER等语句</li>
<li>数据操作语言(DML)：INSERT、UPDATE、DELETE等语句</li>
<li>数据查询语言(DQL)：SELECT语句</li>
<li>数据控制语句(DCL)：GRANT、REVOKE、COMMIT、ROLLBACK等语句</li>
</ol>
<h2 id="1-4-数据库访问接口"><a href="#1-4-数据库访问接口" class="headerlink" title="1.4 数据库访问接口"></a>1.4 数据库访问接口</h2><h3 id="1-4-1-ODBC"><a href="#1-4-1-ODBC" class="headerlink" title="1.4.1 ODBC"></a>1.4.1 ODBC</h3><p>全称：Open Database Connectivity，开放数据库互联</p>
<ol>
<li>访问不同SQL数据库提供了一个共同的接口</li>
<li>使用SQL作为访问数据的标准</li>
<li>一个应用程序可以通过共同的一组代码访问不同的SQL数据库管理系统</li>
</ol>
<h3 id="1-4-2-JDBC"><a href="#1-4-2-JDBC" class="headerlink" title="1.4.2 JDBC"></a>1.4.2 JDBC</h3><p>全称：Java Data Base(Java数据库连接)</p>
<ol>
<li>Java应用程序连接数据库的标准方法</li>
<li>用于执行SQL语句的Java API</li>
</ol>
<h3 id="1-4-3-ADO-NET"><a href="#1-4-3-ADO-NET" class="headerlink" title="1.4.3 ADO.NET"></a>1.4.3 ADO.NET</h3><p>微软在.NET框架下开发设计的一组用于和数据源进行交互额面向对象类库。</p>
<h3 id="1-4-4-PDO"><a href="#1-4-4-PDO" class="headerlink" title="1.4.4 PDO"></a>1.4.4 PDO</h3><p>全称：PHP Data Object</p>
<p>为PHP访问数据库定义了一个轻量级的、一致性的接口，它提供了一个数据访问抽象层，这样，无论使用什么数据库，都可以通过一致的函数执行查询和获取数据。</p>
<h1 id="2-MySQL数据库命令"><a href="#2-MySQL数据库命令" class="headerlink" title="2 MySQL数据库命令"></a>2 MySQL数据库命令</h1><h2 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h2><h3 id="2-1-1-创建数据库"><a href="#2-1-1-创建数据库" class="headerlink" title="2.1.1 创建数据库"></a>2.1.1 创建数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;</span><br><span class="line">[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] </span><br><span class="line">[[DEFAULT] COLLATE &lt;校对规则名&gt;];</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-查看数据库"><a href="#2-1-2-查看数据库" class="headerlink" title="2.1.2 查看数据库"></a>2.1.2 查看数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES [LIKE &#39;数据库名&#39;];</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-修改数据库"><a href="#2-1-3-修改数据库" class="headerlink" title="2.1.3 修改数据库"></a>2.1.3 修改数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE [数据库名] &#123; </span><br><span class="line">[ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |</span><br><span class="line">[ DEFAULT ] COLLATE &lt;校对规则名&gt;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-删除数据库"><a href="#2-1-4-删除数据库" class="headerlink" title="2.1.4 删除数据库"></a>2.1.4 删除数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-选择数据库"><a href="#2-1-5-选择数据库" class="headerlink" title="2.1.5 选择数据库"></a>2.1.5 选择数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE &lt;数据库名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-MySQL存储引擎"><a href="#2-2-MySQL存储引擎" class="headerlink" title="2.2 MySQL存储引擎"></a>2.2 MySQL存储引擎</h2><table>
<thead>
<tr>
<th>功能</th>
<th>MylSAM</th>
<th>MEMORY</th>
<th>InnoDB</th>
<th>Archive</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
</tr>
<tr>
<td>支持事务</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持树索引</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持哈希索引</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持数据缓存</td>
<td>No</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持外键</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
<p>修改默认存储引擎：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET default_storage_engine&#x3D;&lt; 存储引擎名 &gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h2><h3 id="2-3-1-数值类型"><a href="#2-3-1-数值类型" class="headerlink" title="2.3.1 数值类型"></a>2.3.1 数值类型</h3><p>整数类型：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>很小的整数</td>
<td>1个字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>小的整数</td>
<td>2个宇节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>中等大小的整数</td>
<td>3个字节</td>
</tr>
<tr>
<td>INT (INTEGHR)</td>
<td>普通大小的整数</td>
<td>4个字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数</td>
<td>8个字节</td>
</tr>
</tbody></table>
<p>浮点数类型：FLOAT、DOUBLE</p>
<p>定点数类型：DECIMAL(DECIMAL 如果不指定精度，默认为（10，0）)</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4 个字节</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8 个字节</td>
</tr>
<tr>
<td>DECIMAL (M, D)，DEC</td>
<td>压缩的“严格”定点数</td>
<td>M+2 个字节</td>
</tr>
</tbody></table>
<h3 id="2-3-2-日期-时间类型"><a href="#2-3-2-日期-时间类型" class="headerlink" title="2.3.2 日期/时间类型"></a>2.3.2 日期/时间类型</h3><table>
<thead>
<tr>
<th>类型名称</th>
<th>日期格式</th>
<th>日期范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901 ~ 2155</td>
<td>1 个字节</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59 ~ 838:59:59</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01 ~ 9999-12-3</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td>8 个字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td>
<td>4 个字节</td>
</tr>
</tbody></table>
<h3 id="2-3-3-字符串类型"><a href="#2-3-3-字符串类型" class="headerlink" title="2.3.3 字符串类型"></a>2.3.3 字符串类型</h3><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度非二进制字符串</td>
<td>M 字节，1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>变长非二进制字符串</td>
<td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>非常小的非二进制字符串</td>
<td>L+1字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>小的非二进制字符串</td>
<td>L+2字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小的非二进制字符串</td>
<td>L+3字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大的非二进制字符串</td>
<td>L+4字节，在此，L&lt;2^32</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型，只能有一个枚举字符串值</td>
<td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td>
</tr>
<tr>
<td>SET</td>
<td>一个设置，字符串对象可以有零个或 多个SET成员</td>
<td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td>
</tr>
</tbody></table>
<p>PS:</p>
<ol>
<li>VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。</li>
</ol>
<h3 id="2-3-4-二进制类型"><a href="#2-3-4-二进制类型" class="headerlink" title="2.3.4 二进制类型"></a>2.3.4 二进制类型</h3><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>BIT(M)</td>
<td>位字段类型</td>
<td>大约 (M+7)/8 字节</td>
</tr>
<tr>
<td>BINARY(M)</td>
<td>固定长度二进制字符串</td>
<td>M 字节</td>
</tr>
<tr>
<td>VARBINARY (M)</td>
<td>可变长度二进制字符串</td>
<td>M+1 字节</td>
</tr>
<tr>
<td>TINYBLOB (M)</td>
<td>非常小的BLOB</td>
<td>L+1 字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>BLOB (M)</td>
<td>小 BLOB</td>
<td>L+2 字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMBLOB (M)</td>
<td>中等大小的BLOB</td>
<td>L+3 字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGBLOB (M)</td>
<td>非常大的BLOB</td>
<td>L+4 字节，在此，L&lt;2^32</td>
</tr>
</tbody></table>
<h2 id="2-4-数据表操作"><a href="#2-4-数据表操作" class="headerlink" title="2.4 数据表操作"></a>2.4 数据表操作</h2><h3 id="2-4-1-创建数据表"><a href="#2-4-1-创建数据表" class="headerlink" title="2.4.1 创建数据表"></a>2.4.1 创建数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];</span><br></pre></td></tr></table></figure>

<p>查看表结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE &lt;表名&gt;;</span><br><span class="line">或</span><br><span class="line">DESC &lt;表名&gt;;</span><br></pre></td></tr></table></figure>

<p>显示创建表时的CREATE TABLE语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE &lt;表名&gt;\G；</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-修改数据表"><a href="#2-4-2-修改数据表" class="headerlink" title="2.4.2 修改数据表"></a>2.4.2 修改数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; [修改选项]</span><br></pre></td></tr></table></figure>

<p>修改选项语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; ADD COLUMN &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;</span><br><span class="line">| ALTER COLUMN &lt;列名&gt; &#123; SET DEFAULT &lt;默认值&gt; | DROP DEFAULT &#125;</span><br><span class="line">| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">| DROP COLUMN &lt;列名&gt;</span><br><span class="line">| RENAME TO &lt;新表名&gt; &#125;</span><br></pre></td></tr></table></figure>



<p>添加字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]；</span><br></pre></td></tr></table></figure>



<p>修改字段数据类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;</span><br></pre></td></tr></table></figure>

<p>删除字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；</span><br></pre></td></tr></table></figure>

<p>修改字段名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；</span><br></pre></td></tr></table></figure>

<p>修改表名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-删除数据表"><a href="#2-4-3-删除数据表" class="headerlink" title="2.4.3 删除数据表"></a>2.4.3 删除数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]</span><br></pre></td></tr></table></figure>

<h3 id="2-4-4-主键约束"><a href="#2-4-4-主键约束" class="headerlink" title="2.4.4 主键约束"></a>2.4.4 主键约束</h3><p>定义列的同时指定主键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]</span><br></pre></td></tr></table></figure>

<p>定义完所有列之后，指定主键的语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY [字段名]</span><br></pre></td></tr></table></figure>

<p>设置复合主键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PRIMARY KEY [字段1，字段2，…,字段n]</span><br></pre></td></tr></table></figure>

<p>修改表时添加主键约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-5-外键约束"><a href="#2-4-5-外键约束" class="headerlink" title="2.4.5 外键约束"></a>2.4.5 外键约束</h3><p>外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。</p>
<p>外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键某个值。</p>
<p>外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。</p>
<p>外键的主要作用是保持数据的一致性、完整性。</p>
<p>创建表时设置外键约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]</span><br><span class="line">REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">FOREIGN KEY(deptId) REFERENCES tb_dept1(id)</span><br></pre></td></tr></table></figure>



<p>修改表时添加外键约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt;</span><br><span class="line">FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">mysql&gt; ALTER TABLE tb_emp2</span><br><span class="line">    -&gt; ADD CONSTRAINT fk_tb_dept1</span><br><span class="line">    -&gt; FOREIGN KEY(deptId)</span><br><span class="line">    -&gt; REFERENCES tb_dept1(id);</span><br></pre></td></tr></table></figure>



<p>删除外键约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">mysql&gt; ALTER TABLE tb_emp2</span><br><span class="line">    -&gt; DROP FOREIGN KEY fk_tb_dept1;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-6-唯一约束"><a href="#2-4-6-唯一约束" class="headerlink" title="2.4.6 唯一约束"></a>2.4.6 唯一约束</h3><p>Unique Key</p>
<p>要求该列唯一，允许为空，但只能出现一个空值。</p>
<p>唯一约束可以确保一列或者几列不出现重复值。</p>
<p>创建表时设置唯一约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;字段名&gt; &lt;数据类型&gt; UNIQUE</span><br></pre></td></tr></table></figure>

<p>PS：UNIQUE 和 PRIMARY KEY 的区别：一个表可以有多个字段声明为 UNIQUE，但只能有一个 PRIMARY KEY 声明；声明为 PRIMAY KEY 的列不允许有空值，但是声明为 UNIQUE 的字段允许空值的存在。</p>
<p>修改表时添加唯一约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;);</span><br></pre></td></tr></table></figure>



<p>删除唯一约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-7-检查约束"><a href="#2-4-7-检查约束" class="headerlink" title="2.4.7 检查约束"></a>2.4.7 检查约束</h3><p>选取设置检查约束的字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHECK &lt;表达式&gt;</span><br></pre></td></tr></table></figure>



<p>创建表时设置检查约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHECK(&lt;检查约束&gt;)</span><br><span class="line"></span><br><span class="line">CHECK(salary&gt;0 AND salary&lt;100)</span><br></pre></td></tr></table></figure>



<p>修改表时添加检查约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tb_emp7 ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;)</span><br></pre></td></tr></table></figure>



<p>删除检查约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-8-默认值约束"><a href="#2-4-8-默认值约束" class="headerlink" title="2.4.8 默认值约束"></a>2.4.8 默认值约束</h3><p>创建表时设置默认值约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;</span><br></pre></td></tr></table></figure>



<p>修改表时添加默认值约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt;</span><br><span class="line">CHANGE COLUMN &lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;</span><br></pre></td></tr></table></figure>



<p>删除默认值约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt;</span><br><span class="line">CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; DEFAULT NULL;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-8-非空约束"><a href="#2-4-8-非空约束" class="headerlink" title="2.4.8 非空约束"></a>2.4.8 非空约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建时添加：</span><br><span class="line">&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改时添加：</span><br><span class="line">ALTER TABLE &lt;数据表名&gt;</span><br><span class="line">CHANGE COLUMN &lt;字段名&gt;</span><br><span class="line">&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">ALTER TABLE &lt;数据表名&gt;</span><br><span class="line">CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; NULL;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-增、删、改、查"><a href="#2-5-增、删、改、查" class="headerlink" title="2.5 增、删、改、查"></a>2.5 增、删、改、查</h2><h3 id="2-5-1-查询数据表"><a href="#2-5-1-查询数据表" class="headerlink" title="2.5.1 查询数据表"></a>2.5.1 查询数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">&#123;* | &lt;字段列名&gt;&#125;</span><br><span class="line">[</span><br><span class="line">FROM &lt;表 1&gt;, &lt;表 2&gt;…</span><br><span class="line">[WHERE &lt;表达式&gt;</span><br><span class="line">[GROUP BY &lt;group by definition&gt;</span><br><span class="line">[HAVING &lt;expression&gt; [&#123;&lt;operator&gt; &lt;expression&gt;&#125;…]]</span><br><span class="line">[ORDER BY &lt;order by definition&gt;]</span><br><span class="line">[LIMIT[&lt;offset&gt;,] &lt;row count&gt;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中，各条子句的含义如下：</p>
<ul>
<li><code>&#123;*|&lt;字段列名&gt;&#125;</code>包含星号通配符的字段列表，表示查询的字段，其中字段列至少包含一个字段名称，如果要查询多个字段，多个字段之间要用逗号隔开，最后一个字段后不要加逗号。</li>
<li><code>FROM &lt;表 1&gt;，&lt;表 2&gt;…</code>，表 1 和表 2 表示查询数据的来源，可以是单个或多个。</li>
<li>WHERE 子句是可选项，如果选择该项，将限定查询行必须满足的查询条件。</li>
<li><code>GROUP BY&lt; 字段 &gt;</code>，该子句告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。</li>
<li><code>[ORDER BY&lt; 字段 &gt;]</code>，该子句告诉 MySQL 按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC）。</li>
<li><code>[LIMIT[，]]</code>，该子句告诉 MySQL 每次显示查询出来的数据条数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;;</span><br><span class="line">&#x2F;&#x2F;DISTINCT设置去重</span><br></pre></td></tr></table></figure>

<h3 id="2-5-2-设置别名"><a href="#2-5-2-设置别名" class="headerlink" title="2.5.2 设置别名"></a>2.5.2 设置别名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;表名&gt; [AS] &lt;别名&gt;</span><br><span class="line">&lt;列名&gt; [AS] &lt;列别名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-排序查询结果"><a href="#2-5-3-排序查询结果" class="headerlink" title="2.5.3 排序查询结果"></a>2.5.3 排序查询结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ORDER BY &#123;&lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt;&#125; [ASC|DESC]</span><br></pre></td></tr></table></figure>

<h3 id="2-5-4-条件查询"><a href="#2-5-4-条件查询" class="headerlink" title="2.5.4 条件查询"></a>2.5.4 条件查询</h3><p>单一条件查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name,height</span><br><span class="line">    -&gt; FROM tb_students_info</span><br><span class="line">    -&gt; WHERE height&#x3D;170;</span><br></pre></td></tr></table></figure>

<p>多条件查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tb_students_info</span><br><span class="line">    -&gt; WHERE age&gt;21 AND height&gt;&#x3D;175;</span><br></pre></td></tr></table></figure>

<p>使用LIKE模糊查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;表达式1&gt; [NOT] LIKE &lt;表达式2&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>百分号(%)</p>
<blockquote>
<p>百分号是 MySQL 中常用的一种通配符，在过滤条件中，百分号可以表示任何字符串，并且该字符串可以出现任意次。</p>
</blockquote>
</li>
<li><p>下划线(_)</p>
<blockquote>
<p>匹配单个字符</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM tb_students_info</span><br><span class="line">    -&gt; WHERE name LIKE &#39;T%&#39;;</span><br><span class="line">    </span><br><span class="line">mysql&gt; SELECT name FROM tb_students_info</span><br><span class="line">    -&gt; WHERE name LIKE &#39;____y&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-5-运算符"><a href="#2-5-5-运算符" class="headerlink" title="2.5.5 运算符"></a>2.5.5 运算符</h3><table>
<thead>
<tr>
<th>优先级由低到高排列</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>=(赋值运算）、:=</td>
</tr>
<tr>
<td>2</td>
<td>II、OR</td>
</tr>
<tr>
<td>3</td>
<td>XOR</td>
</tr>
<tr>
<td>4</td>
<td>&amp;&amp;、AND</td>
</tr>
<tr>
<td>5</td>
<td>NOT</td>
</tr>
<tr>
<td>6</td>
<td>BETWEEN、CASE、WHEN、THEN、ELSE</td>
</tr>
<tr>
<td>7</td>
<td>=(比较运算）、&lt;=&gt;、&gt;=、&gt;、&lt;=、&lt;、&lt;&gt;、!=、 IS、LIKE、REGEXP、IN</td>
</tr>
<tr>
<td>8</td>
<td>|</td>
</tr>
<tr>
<td>9</td>
<td>&amp;</td>
</tr>
<tr>
<td>10</td>
<td>&lt;&lt;、&gt;&gt;</td>
</tr>
<tr>
<td>11</td>
<td>-(减号）、+</td>
</tr>
<tr>
<td>12</td>
<td>*、/、%</td>
</tr>
<tr>
<td>13</td>
<td>^</td>
</tr>
<tr>
<td>14</td>
<td>-(负号）、〜（位反转）</td>
</tr>
<tr>
<td>15</td>
<td>!</td>
</tr>
</tbody></table>
<h3 id="2-5-6-内连接（INNER-JOIN）"><a href="#2-5-6-内连接（INNER-JOIN）" class="headerlink" title="2.5.6 内连接（INNER JOIN）"></a>2.5.6 内连接（INNER JOIN）</h3><p>通过在查询中设置连接条件的方式，来移除查询结果集中某些数据行后的交叉连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &lt;列名1，列名2 …&gt;</span><br><span class="line">FROM &lt;表名1&gt; INNER JOIN &lt;表名2&gt; [ ON子句]</span><br></pre></td></tr></table></figure>

<p>INNER关键字可省略</p>
<h3 id="2-5-7-外连接（LEFT-RIGHT-JOIN）"><a href="#2-5-7-外连接（LEFT-RIGHT-JOIN）" class="headerlink" title="2.5.7 外连接（LEFT/RIGHT JOIN）"></a>2.5.7 外连接（LEFT/RIGHT JOIN）</h3><p>先将连接的表分为基表和参考表，再以基表为依据返回满足和不满足条件的记录。</p>
<ol>
<li><p>左外连接</p>
<blockquote>
<p>关键字：LEFT OUTER JOIN或者LEFT JOIN</p>
<ul>
<li>接收该关键字左表（基表）的所有行，并用这些行与该关键字右表（参考表）中的行进行匹配，即匹配左表中的每一行及右表中符合条件的行。</li>
<li>左外连接的结果集中，除了匹配的行之外，还包括左表中有但在右表中不匹配的行，对于这样的行，从右表中选择的列的值被设置为NULL，即左外连接的结果集中的NULL值表示右表中没有找到与左表符合的记录。</li>
</ul>
</blockquote>
</li>
<li><p>右外连接</p>
<blockquote>
<p>关键字：RIGHT OUTER JOIN或者RIGHT JOIN</p>
<p>除了基表、参考表互换，其余与左外连接相同</p>
</blockquote>
</li>
</ol>
<h3 id="2-5-8-子查询"><a href="#2-5-8-子查询" class="headerlink" title="2.5.8 子查询"></a>2.5.8 子查询</h3><ol>
<li><p>IN子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;表达式&gt; [NOT] IN &lt;子查询&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较运算符子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;表达式&gt; &#123;&#x3D; | &lt; | &gt; | &gt;&#x3D; | &lt;&#x3D; | &lt;&#x3D;&gt; | &lt; &gt; | !&#x3D; &#125;</span><br><span class="line">&#123; ALL | SOME | ANY&#125; &lt;子查询&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EXIST子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXIST &lt;子查询&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM tb_students_info</span><br><span class="line">    -&gt; WHERE dept_id IN</span><br><span class="line">    -&gt; (SELECT dept_id</span><br><span class="line">    -&gt; FROM tb_departments</span><br><span class="line">    -&gt; WHERE dept_type&#x3D; &#39;A&#39; );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">mysql&gt; SELECT * FROM tb_students_info</span><br><span class="line">    -&gt; WHERE EXISTS</span><br><span class="line">    -&gt; (SELECT dept_name</span><br><span class="line">    -&gt; FROM tb_departments</span><br><span class="line">    -&gt; WHERE dept_id&#x3D;7);</span><br></pre></td></tr></table></figure>

<h3 id="2-5-9-分组查询"><a href="#2-5-9-分组查询" class="headerlink" title="2.5.9 分组查询"></a>2.5.9 分组查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GROUP BY &#123; &lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt; &#125; [ASC | DESC]</span><br></pre></td></tr></table></figure>

<h3 id="2-5-10-HAVING：指定过滤条件"><a href="#2-5-10-HAVING：指定过滤条件" class="headerlink" title="2.5.10 HAVING：指定过滤条件"></a>2.5.10 HAVING：指定过滤条件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HAVING &lt;条件&gt;</span><br></pre></td></tr></table></figure>



<p>与WHERE的区别：</p>
<ul>
<li>WHERE 子句主要用于过滤数据行，而 HAVING 子句主要用于过滤分组，即 HAVING 子句基于分组的聚合值而不是特定行的值来过滤数据，主要用来过滤分组。</li>
<li>WHERE 子句不可以包含聚合函数，HAVING 子句中的条件可以包含聚合函数。</li>
<li>HAVING 子句是在数据分组后进行过滤，WHERE 子句会在数据分组前进行过滤。WHERE 子句排除的行不包含在分组中，可能会影响 HAVING 子句基于这些值过滤掉的分组。</li>
</ul>
<h3 id="2-5-11-正则表达式查询（REGEXP）"><a href="#2-5-11-正则表达式查询（REGEXP）" class="headerlink" title="2.5.11 正则表达式查询（REGEXP）"></a>2.5.11 正则表达式查询（REGEXP）</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>例子</th>
<th>匹配值示例</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配文本的开始字符</td>
<td>‘^b’ 匹配以字母 b 开头 的字符串</td>
<td>book、big、banana、 bike</td>
</tr>
<tr>
<td>$</td>
<td>匹配文本的结束字符</td>
<td>‘st$’ 匹配以 st 结尾的字 符串</td>
<td>test、resist、persist</td>
</tr>
<tr>
<td>.</td>
<td>匹配任何单个字符</td>
<td>‘b.t’ 匹配任何 b 和 t 之间有一个字符</td>
<td>bit、bat、but、bite</td>
</tr>
<tr>
<td>*</td>
<td>匹配零个或多个在它前面的字 符</td>
<td>‘f*n’ 匹配字符 n 前面有 任意个字符 f</td>
<td>fn、fan、faan、abcn</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的字符 1 次或多次</td>
<td>‘ba+’ 匹配以 b 开头，后 面至少紧跟一个 a</td>
<td>ba、bay、bare、battle</td>
</tr>
<tr>
<td>&lt;字符串&gt;</td>
<td>匹配包含指定字符的文本</td>
<td>‘fa’</td>
<td>fan、afa、faad</td>
</tr>
<tr>
<td>[字符集合]</td>
<td>匹配字符集合中的任何一个字 符</td>
<td>‘[xz]’匹配 x 或者 z</td>
<td>dizzy、zebra、x-ray、 extra</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在括号中的任何字符</td>
<td>‘[^abc]’ 匹配任何不包 含 a、b 或 c 的字符串</td>
<td>desk、fox、f8ke</td>
</tr>
<tr>
<td>字符串{n,}</td>
<td>匹配前面的字符串至少 n 次</td>
<td>b{2} 匹配 2 个或更多 的 b</td>
<td>bbb、 bbbb、 bbbbbbb</td>
</tr>
<tr>
<td>字符串 {n,m}</td>
<td>匹配前面的字符串至少 n 次， 至多 m 次</td>
<td>b{2,4} 匹配最少 2 个， 最多 4 个 b</td>
<td>bbb、 bbbb</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tb_departments</span><br><span class="line">    -&gt; WHERE dept_name REGEXP &#39;^C&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-12-插入数据"><a href="#2-5-12-插入数据" class="headerlink" title="2.5.12 插入数据"></a>2.5.12 插入数据</h3><ol>
<li><p>INSERT…VALUES</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; [ &lt;列名1&gt; [ , … &lt;列名n&gt;] ]</span><br><span class="line">VALUES (值1) [… , (值n) ];</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>INSERT…SET</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt;</span><br><span class="line">SET &lt;列名1&gt; &#x3D; &lt;值1&gt;,</span><br><span class="line">        &lt;列名2&gt; &#x3D; &lt;值2&gt;,</span><br><span class="line">        …</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="2-5-13-更改数据"><a href="#2-5-13-更改数据" class="headerlink" title="2.5.13 更改数据"></a>2.5.13 更改数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段 1&#x3D;值 1 [,字段 2&#x3D;值 2… ] [WHERE 子句 ]</span><br><span class="line">[ORDER BY 子句] [LIMIT 子句]</span><br></pre></td></tr></table></figure>

<h3 id="2-5-14-删除数据"><a href="#2-5-14-删除数据" class="headerlink" title="2.5.14 删除数据"></a>2.5.14 删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]</span><br></pre></td></tr></table></figure>

<h2 id="2-6-视图操作"><a href="#2-6-视图操作" class="headerlink" title="2.6 视图操作"></a>2.6 视图操作</h2><h3 id="2-6-1-创建视图"><a href="#2-6-1-创建视图" class="headerlink" title="2.6.1 创建视图"></a>2.6.1 创建视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;单表</span><br><span class="line">CREATE VIEW view_students_info</span><br><span class="line">AS SELECT * FROM tb_students_info;</span><br><span class="line">&#x2F;&#x2F;多表</span><br><span class="line">mysql&gt; CREATE VIEW v_students_info</span><br><span class="line">    -&gt; (s_id,s_name,d_id,s_age,s_sex,s_height,s_date)</span><br><span class="line">    -&gt; AS SELECT id,name,dept_id,age,sex,height,login_date</span><br><span class="line">    -&gt; FROM tb_students_info;</span><br></pre></td></tr></table></figure>



<p>查询视图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE 视图名；</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-修改视图"><a href="#2-6-2-修改视图" class="headerlink" title="2.6.2 修改视图"></a>2.6.2 修改视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-删除视图"><a href="#2-6-3-删除视图" class="headerlink" title="2.6.3 删除视图"></a>2.6.3 删除视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW &lt;视图名1&gt; [ , &lt;视图名2&gt; …]</span><br></pre></td></tr></table></figure>

<h2 id="2-7-存储过程"><a href="#2-7-存储过程" class="headerlink" title="2.7 存储过程"></a>2.7 存储过程</h2><h3 id="2-7-1-创建存储过程"><a href="#2-7-1-创建存储过程" class="headerlink" title="2.7.1 创建存储过程"></a>2.7.1 创建存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE &lt;过程名&gt; ( [过程参数[,…] ] ) &lt;过程体&gt;</span><br><span class="line">[过程参数[,…] ] 格式</span><br><span class="line">[ IN | OUT | INOUT ] &lt;参数名&gt; &lt;类型&gt;</span><br></pre></td></tr></table></figure>

<p>不带参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建</span><br><span class="line">mysql&gt; DELIMITER &#x2F;&#x2F;</span><br><span class="line">mysql&gt; CREATE PROCEDURE ShowStuScore()</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; SELECT * FROM tb_students_score;</span><br><span class="line">    -&gt; END &#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;执行    </span><br><span class="line">mysql&gt; DELIMITER ;</span><br><span class="line">mysql&gt; CALL ShowStuScore();</span><br></pre></td></tr></table></figure>



<p>带参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建</span><br><span class="line">mysql&gt; DELIMITER &#x2F;&#x2F;</span><br><span class="line">mysql&gt; CREATE PROCEDURE GetScoreByStu</span><br><span class="line">    -&gt; (IN name VARCHAR(30))</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; SELECT student_score FROM tb_students_score</span><br><span class="line">    -&gt; WHERE student_name&#x3D;name;</span><br><span class="line">    -&gt; END &#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">mysql&gt; DELIMITER ;</span><br><span class="line">mysql&gt; CALL GetScoreByStu(&#39;Green&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-修改存储过程"><a href="#2-7-2-修改存储过程" class="headerlink" title="2.7.2 修改存储过程"></a>2.7.2 修改存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER PROCEDURE &lt;过程名&gt; [ &lt;特征&gt; … ]</span><br></pre></td></tr></table></figure>

<h3 id="2-7-3-删除存储过程"><a href="#2-7-3-删除存储过程" class="headerlink" title="2.7.3 删除存储过程"></a>2.7.3 删除存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP &#123; PROCEDURE | FUNCTION &#125; [ IF EXISTS ] &lt;过程名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-8-触发器"><a href="#2-8-触发器" class="headerlink" title="2.8 触发器"></a>2.8 触发器</h2><p>MySQL 数据库中触发器是一个特殊的存储过程，不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，只要一个预定义的事件发生就会被 MySQL自动调用。</p>
<p>引发触发器执行的事件一般如下：</p>
<ul>
<li>增加一条学生记录时，会自动检查年龄是否符合范围要求。</li>
<li>每当删除一条学生信息时，自动删除其成绩表上的对应记录。</li>
<li>每当删除一条数据时，在数据库存档表中保留一个备份副本。</li>
</ul>
<p>触发程序的优点如下：</p>
<ul>
<li>触发程序的执行是自动的，当对触发程序相关表的数据做出相应的修改后立即执行。</li>
<li>触发程序可以通过数据库中相关的表层叠修改另外的表。</li>
<li>触发程序可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。</li>
</ul>
<ol>
<li>INSERT触发器</li>
<li>UPDATE触发器</li>
<li>DELETE触发器</li>
</ol>
<h2 id="2-9-索引"><a href="#2-9-索引" class="headerlink" title="2.9 索引"></a>2.9 索引</h2><p>类似哈希表</p>
<p>索引物理分类：</p>
<ol>
<li><p>B-树索引</p>
<blockquote>
<ul>
<li>叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。</li>
<li>分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。</li>
<li>根节点：一个B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。</li>
</ul>
</blockquote>
</li>
<li><p>哈希索引</p>
<blockquote>
<p>MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B- 树索引和 HASH 索引，且将 HASH 当成默认索引。</p>
</blockquote>
</li>
</ol>
<p>索引逻辑分类：</p>
<ol>
<li><p>普通索引</p>
<blockquote>
<p>加快对数据的访问速度，通常使用关键字INDEX或KEY</p>
</blockquote>
</li>
<li><p>唯一性索引</p>
<blockquote>
<p>不允许索引列具有相同索引值的索引，避免数据重复</p>
</blockquote>
</li>
<li><p>主键索引</p>
<blockquote>
<p>PRIMARY KEY</p>
</blockquote>
</li>
<li><p>空间索引</p>
<blockquote>
<p>地理空间数据类型GEOMETRY</p>
</blockquote>
</li>
<li><p>全文索引</p>
</li>
</ol>
<h3 id="2-9-1-创建索引"><a href="#2-9-1-创建索引" class="headerlink" title="2.9.1 创建索引"></a>2.9.1 创建索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.CREATE INDEX语句</span><br><span class="line">CREATE &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;长度&gt;] [ ASC | DESC])</span><br><span class="line"></span><br><span class="line">2.CREATE TABLE或者 ALTER TABLE中直接添加</span><br></pre></td></tr></table></figure>



<p>查看索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM &lt;表名&gt; [ FROM &lt;数据库名&gt;]</span><br></pre></td></tr></table></figure>

<h3 id="2-9-2-删除索引"><a href="#2-9-2-删除索引" class="headerlink" title="2.9.2 删除索引"></a>2.9.2 删除索引</h3><ol>
<li><p>使用DROP INDEX语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ALTER TABLE语句</p>
<ul>
<li>DROP PRIMARY KEY：表示删除表中的主键。一个表只有一个主键，主键也是一个索引。</li>
<li>DROP INDEX index_name：表示删除名称为 index_name 的索引。</li>
<li>DROP FOREIGN KEY fk_symbol：表示删除外键。</li>
</ul>
</li>
</ol>
<h2 id="2-10-用户"><a href="#2-10-用户" class="headerlink" title="2.10 用户"></a>2.10 用户</h2><p>避免用户恶意冒名使用root账号控制数据库，不同用户不同权限，确保数据的安全访问</p>
<h3 id="2-10-1-创建用户"><a href="#2-10-1-创建用户" class="headerlink" title="2.10.1 创建用户"></a>2.10.1 创建用户</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &lt;用户名&gt; [ IDENTIFIED ] BY [ PASSWORD ] &lt;口令&gt;</span><br></pre></td></tr></table></figure>

<p> 1) &lt;用户名&gt;</p>
<p>指定创建用户账号，格式为 ‘user_name’@’host_name’。这里<code>user_name</code>是用户名，<code>host_name</code>为主机名，即用户连接 MySQL 时所在主机的名字。若在创建的过程中，只给出了账户的用户名，而没指定主机名，则主机名默认为“%”，表示一组主机。</p>
<p> 2) PASSWORD</p>
<p>可选项，用于指定散列口令，即若使用明文设置口令，则需忽略<code>PASSWORD</code>关键字；若不想以明文设置口令，且知道 PASSWORD() 函数返回给密码的散列值，则可以在口令设置语句中指定此散列值，但需要加上关键字<code>PASSWORD</code>。</p>
<p> 3) IDENTIFIED BY子句</p>
<p>用于指定用户账号对应的口令，若该用户账号无口令，则可省略此子句。</p>
<p> 4) &lt;口令&gt;</p>
<p>指定用户账号的口令，在<code>IDENTIFIED BY</code>关键字或<code>PASSWOED</code>关键字之后。给定的口令值可以是只由字母和数字组成的明文，也可以是通过 PASSWORD() 函数得到的散列值。</p>
<p>使用 CREATE USER 语句应该注意以下几点：</p>
<ul>
<li>如果使用 CREATE USER 语句时没有为用户指定口令，那么 MySQL 允许该用户可以不使用口令登录系统，然而从安全的角度而言，不推荐这种做法。</li>
<li>使用 CREATE USER 语句必须拥有 MySQL 中 MySQL 数据库的 INSERT 权限或全局 CREATE USER 权限。</li>
<li>使用 CREATE USER 语句创建一个用户账号后，会在系统自身的 MySQL 数据库的 user 表中添加一条新记录。若创建的账户已经存在，则语句执行时会出现错误。</li>
<li>新创建的用户拥有的权限很少。他们可以登录 MySQL，只允许进行不需要权限的操作，如使用 SHOW 语句查询所有存储引擎和字符集的列表等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#39;james&#39;@&#39;localhost&#39;</span><br><span class="line">    -&gt; IDENTIFIED BY &#39;tiger&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-2-修改用户"><a href="#2-10-2-修改用户" class="headerlink" title="2.10.2 修改用户"></a>2.10.2 修改用户</h3><p>修改用户名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME USER &lt;旧用户&gt; TO &lt;新用户&gt;</span><br><span class="line"></span><br><span class="line">mysql&gt; RENAME USER james@&#39;localhost&#39;</span><br><span class="line">    -&gt; TO jack@&#39;localhost&#39;;</span><br></pre></td></tr></table></figure>



<p>修改用户口令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD [ FOR &lt;用户名&gt; ] &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">    PASSWORD(&#39;新明文口令&#39;)</span><br><span class="line">    | OLD_PASSWORD(&#39;旧明文口令&#39;)</span><br><span class="line">    | &#39;加密口令值&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql&gt; SET PASSWORD FOR &#39;jack&#39;@&#39;localhost&#39;&#x3D;</span><br><span class="line">    -&gt; PASSWORD(&#39;lion&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="2-10-3-删除用户"><a href="#2-10-3-删除用户" class="headerlink" title="2.10.3 删除用户"></a>2.10.3 删除用户</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER &lt;用户名1&gt; [ , &lt;用户名2&gt; ]…</span><br></pre></td></tr></table></figure>

<h3 id="2-10-4-授予用户权限"><a href="#2-10-4-授予用户权限" class="headerlink" title="2.10.4 授予用户权限"></a>2.10.4 授予用户权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT</span><br><span class="line">&lt;权限类型&gt; [ ( &lt;列名&gt; ) ] [ , &lt;权限类型&gt; [ ( &lt;列名&gt; ) ] ]</span><br><span class="line">ON &lt;对象&gt; &lt;权限级别&gt; TO &lt;用户&gt;</span><br><span class="line">其中&lt;用户&gt;的格式：</span><br><span class="line">&lt;用户名&gt; [ IDENTIFIED ] BY [ PASSWORD ] &lt;口令&gt;</span><br><span class="line">[ WITH GRANT OPTION]</span><br><span class="line">| MAX_QUERIES_PER_HOUR &lt;次数&gt;</span><br><span class="line">| MAX_UPDATES_PER_HOUR &lt;次数&gt;</span><br><span class="line">| MAX_CONNECTIONS_PER_HOUR &lt;次数&gt;</span><br><span class="line">| MAX_USER_CONNECTIONS &lt;次数&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-5-删除用户权限"><a href="#2-10-5-删除用户权限" class="headerlink" title="2.10.5 删除用户权限"></a>2.10.5 删除用户权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;回收某些特定的权限</span><br><span class="line">REVOKE &lt;权限类型&gt; [ ( &lt;列名&gt; ) ] [ , &lt;权限类型&gt; [ ( &lt;列名&gt; ) ] ]…</span><br><span class="line">ON &lt;对象类型&gt; &lt;权限名&gt; FROM &lt;用户1&gt; [ , &lt;用户2&gt; ]…</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;回收特定用户的所有权限</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION</span><br><span class="line">FROM user &lt;用户1&gt; [ , &lt;用户2&gt; ]…</span><br></pre></td></tr></table></figure>

<h2 id="2-11-事务"><a href="#2-11-事务" class="headerlink" title="2.11 事务"></a>2.11 事务</h2><p>特性：</p>
<ol>
<li><p>原子性(Atomicity)</p>
<blockquote>
<p>要么全部执行，要么全都不执行</p>
</blockquote>
</li>
<li><p>一致性(Consistency)</p>
</li>
<li><p>隔离性(Isolation)</p>
<blockquote>
<p>多个事务同时运行，互斥不干扰</p>
</blockquote>
</li>
<li><p>持久性(Durability)</p>
<blockquote>
<p>对数据的变动永久有效</p>
</blockquote>
</li>
</ol>
<h3 id="2-11-1-开始事务"><a href="#2-11-1-开始事务" class="headerlink" title="2.11.1 开始事务"></a>2.11.1 开始事务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN TRANSACTION &lt;事务名称&gt; |@&lt;事务变量名称&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-11-2-提交事务"><a href="#2-11-2-提交事务" class="headerlink" title="2.11.2 提交事务"></a>2.11.2 提交事务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMIT TRANSACTION &lt;事务名称&gt; |@&lt;事务变量名称&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-11-3-撤销事务"><a href="#2-11-3-撤销事务" class="headerlink" title="2.11.3 撤销事务"></a>2.11.3 撤销事务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROLLBACK [TRANSACTION]</span><br><span class="line">[&lt;事务名称&gt;| @&lt;事务变量名称&gt; | &lt;存储点名称&gt;| @ &lt;含有存储点名称的变量名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-12-备份-INTO-OUTFILE"><a href="#2-12-备份-INTO-OUTFILE" class="headerlink" title="2.12 备份(INTO OUTFILE)"></a>2.12 备份(INTO OUTFILE)</h2><p>SELECT INTO OUTFILE语句把表数据导出到一个文本文件中进行备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_db.tb_students_info</span><br><span class="line">    -&gt; INTO OUTFILE &#39;C:&#x2F;ProgramData&#x2F;MySQL&#x2F;MySQL Server 5.7&#x2F;Uploads&#x2F;file.txt&#39;</span><br><span class="line">    -&gt; FIELDS TERMINATED BY &#39;&quot;&#39;</span><br><span class="line">    -&gt; LINES TERMINATED BY &#39;?&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="2-13-数据库恢复-LOAD-DATA"><a href="#2-13-数据库恢复-LOAD-DATA" class="headerlink" title="2.13 数据库恢复(LOAD DATA)"></a>2.13 数据库恢复(LOAD DATA)</h2><p>以备份为基础，与备份相对应的系统维护和管理操作</p>
<p>数据库恢复机制关键问题：</p>
<ol>
<li>如何建立冗余数据</li>
<li>如何利用这些冗余数据实施数据库恢复</li>
</ol>
<p>建立冗余数据技术：</p>
<ol>
<li><p>数据转储</p>
<blockquote>
<p>DBA定期将整个数据库复制到磁带或另一个磁盘上保存起来的过程（后备副本、后援副本）</p>
</blockquote>
</li>
<li><p>登录日志文件</p>
</li>
</ol>
<p>可使用 LOAD DATA…INFILE 语句来恢复先前备份的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; LOAD DATA INFILE &#39;C:&#x2F;ProgramData&#x2F;MySQL&#x2F;MySQL Server 5.7&#x2F;</span><br><span class="line">Uploads&#x2F;file.txt&#39;</span><br><span class="line">    -&gt; INTO TABLE test_db.tb_students_copy</span><br><span class="line">    -&gt; FIELDS TERMINATED BY &#39;,&#39;</span><br><span class="line">    -&gt; OPTIONALLY ENCLOSED BY &#39;&quot;&#39;</span><br><span class="line">    -&gt; LINES TERMINATED BY &#39;?&#39;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>降维与度量学习</title>
    <url>/jaheel.github.io/2020/10/19/%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>懒惰学习(lazy learning)</p>
<blockquote>
<p>在训练阶段把样本保存起来，训练时间开销为零，待收到测试样本后再进行处理</p>
</blockquote>
<p>急切学习(eager learning)</p>
<blockquote>
<p>再训练阶段对样本进行学习处理的方法</p>
</blockquote>
<p>降维(dimension reduction)</p>
<blockquote>
<p>通过某种数学变换将原始高维属性空间转变为一个低维“子空间”</p>
<p>在这个子空间中样本密度大幅提高，距离计算也变得更为容易</p>
</blockquote>
<p>多维缩放(Multiple Dimensional Scaling, MDS)</p>
<p>主成分分析(Principle Component Analysis, PCA)</p>
<p>核主成分分析(Kernelized PCA, KPCA)</p>
<p>等度量映射(Isometric Mapping)</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
</search>
