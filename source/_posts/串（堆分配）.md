---
title: 串（堆分配）
tags:
  - C
  - data structure
  - Algorithm
  - String

categories: 数据结构
comments: false
---

教材：严版数据结构

页码：P75-77

IDE：VS2015

实现：堆分配的各种基本操作

<!-- more -->



代码：

```c
#include<iostream>
#include<stdlib.h>
using namespace std;
#define OK 1
#define FALSE 0
#define ERROR 0
#define TRUE 1
#define Status int
typedef struct {
	char *ch;
	int length;
}HString;
 
Status StrInsert(HString &S, int pos, HString T)
{
	if (pos<1 || pos>S.length + 1)
		return ERROR;
	if (T.length)
	{
		S.ch = (char *)realloc(S.ch, (S.length + T.length) * sizeof(char));
		
		for (int i = S.length - 1; i >= pos - 1; --i)
			S.ch[i + T.length] = S.ch[i];
		for (int i = 0; i < T.length; i++)
			S.ch[pos - 1 + i] = T.ch[i];
		S.length += T.length;
	}
}
 
Status StrAssign(HString &T, char *chars)
{
	int i;
	char *c = chars;
	if (T.ch)
		free(T.ch);
	for (i = 0; *c; ++i, ++c);
	if (!i)
	{
		T.ch = NULL;
		T.length = 0;
	}
	else
	{
		if (!(T.ch = (char *)malloc(i * sizeof(char))))
			exit(OVERFLOW);
		for (int j = 0; j < i; j++)
		{
			T.ch[j] = chars[j];
		}
		T.length = i;
	}
	return OK;
}
 
int StrLength(HString S)
{
	return S.length;
}
 
int StrCompare(HString S, HString T)
{
	for (int i = 0; i < S.length&&i < T.length; ++i)
		if (S.ch[i] != T.ch[i])
			return S.ch[i] - T.ch[i];
	return S.length - T.length;
}
 
Status ClearString(HString &S)
{
	if (S.ch)
	{
		free(S.ch);
		S.ch = NULL;
	}
	S.length = 0;
	return OK;
}
 
Status Concat(HString &T, HString S1, HString S2)
{
	if (T.ch)
		free(T.ch);
	T.ch = (char *)malloc((S1.length + S2.length) * sizeof(char));
	
	for (int i = 0; i < S1.length; i++)
	{
		T.ch[i] = S1.ch[i];
	}
	T.length = S1.length + S2.length;
	for (int i = 0; i < S2.length; i++)
	{
		T.ch[S1.length + i] = S2.ch[i];
	}
	return OK;
}
 
Status SubString(HString &Sub, HString S, int pos, int len)
{
	if (pos<0 || pos>S.length || len<0 || len>S.length - pos + 1)
		return ERROR;
	if (Sub.ch)
		free(Sub.ch);
	if (!len)
	{
		Sub.ch = NULL;
		Sub.length = 0;
	}
	else
	{
		Sub.ch = (char *)malloc(len * sizeof(char));
		for (int i = 0; i < len; i++)
		{
			Sub.ch[i] = S.ch[pos - 1 + i];
		}
		Sub.length = len;
	}
	return OK;
}
 
void DispStr(HString S)
{
	int i;
	if (S.length > 0)
	{
		for (i = 0; i < S.length; i++)
		{
			cout << S.ch[i];
		}
		cout << endl;
	}
}
 
Status StrCopy(HString &S, HString T)
{
	if (S.ch)
		free(S.ch);
 
	S.ch = (char *)malloc((T.length) * sizeof(char));
 
	for (int i = 0; i < T.length; i++)
	{
		S.ch[i] = T.ch[i];
	}
	S.length = T.length;
	return OK;
}
 
Status StrDelete(HString &S, int pos, int len)
{
	if (pos<0 || pos>S.length || len<0 || len>S.length - pos + 1)
		return ERROR;
	for (int i = 0; i < len; i++)
	{
		S.ch[pos - 1 + i] = S.ch[pos - 1 + len + i];
	}
	S.length -= len;
	return OK;
}
 
void main()
{
	HString T, S, S1, S2, Sub;
	int pos, len;
	char *a, str[100], *chars = "House";
	T.ch = NULL;
	S.ch = NULL;
	S1.ch = NULL;
	S2.ch = NULL;
	Sub.ch = NULL;
	cout << "输出字符串常量chars:" << chars << endl;
	StrAssign(T, chars);
	cout << "生成一个其值等于串常量chars的串T：";
	DispStr(T);
	StrCopy(S, T);
	cout << "将串T的值复制到串S中，串S的值为：";
	DispStr(S);
	cout << "串S的长度为：" << StrLength(S) << endl;
	cout << "比较串S和串T的大小：" << StrCompare(S, T) << endl;
	cout << "将S清为空串！" << endl;
	ClearString(S);
	cout << "串S的值为：";
	DispStr(S);
	cout << "串T的值为：";
	DispStr(T);
	a = str;
	cout << "输入串S1：";
	cin >> a;
	StrAssign(S1, a);
	cout << "串S1的值为：";
	DispStr(S1);
	cout << "输入串S2：";
	cin >> a;
	StrAssign(S2, a);
	cout << "串S2的值为：";
	DispStr(S2);
	cout << "返回由S1和S2联接而成的新串S：";
	Concat(S, S1, S2);
	DispStr(S);
	cout << "输入S的子串的起始字符位置：";
	cin >> pos;
	cout << "输入S的子串的长度";
	cin >> len;
	cout << "用Sub返回串S的第" << pos << "个字符起长度为" << len << "的子串：";
	SubString(Sub, S, pos, len);
	DispStr(Sub);
	cout << "输入串S的插入位置:";
	cin >> pos;
	cout << "在串S的第" << pos << "个位置插入串T，插入后串S的值为：";
	StrInsert(S, pos, T);
	DispStr(S);
	cout << "输入串S删除的子串的起始字符位置：";
	cin >> pos;
	cout << "输入串S删除的子串的长度：";
	cin >> len;
	cout << "串S中删除第" << pos << "个字符起长度为" << len << "的子串，删除后S的值为：";
	StrDelete(S, pos, len);
	DispStr(S);
	system("pause");
}
```

