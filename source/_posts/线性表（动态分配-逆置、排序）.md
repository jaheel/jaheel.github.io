---
title: 线性表（动态分配 逆置、排序）
tags:
  - C
  - data structure
  - Algorithm
  - Linked List

categories: 数据结构
comments: false
---

1. 结构：线性表动态分配顺序存储结构

2. 目的：逆置

   <!--more-->

3. 代码如下：

   ```c
   #include<stdio.h>
   #include<stdlib.h>
   #include<time.h>
   #include<iostream>
    
   using namespace std;
   #define TRUE 1
   #define FALSE 0
   #define OK 1
   #define ERROR 0
   #define OVERFLOW -2
   #define LIST_INIT_SIZE 100
   #define LISTINCREMENT 10
    
   typedef int Status;
   typedef int ElemType;
    
   typedef struct 
   {
   	ElemType *elem;
   	int length;
   	int listsize;
   }SqList;
    
   Status InitList_Sq(SqList &L)
   {
   	L.elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));
   	if (!L.elem)
   		return OVERFLOW;
   	L.length = 0;
   	L.listsize = LIST_INIT_SIZE;
   	return OK;
   }
    
   Status ListCreate_Sq(SqList &L, int n)
   {
   	int i;
   	srand(time(0));
   	for (i = 0; i < n; i++)
   	{
   		L.elem[i] = rand() % 90 + 10;
   		++L.length;
   	}
   	if (L.length == 0)
   		return ERROR;
   	return OK;
   }
    
   Status ListOutput_Sq(SqList L)
   {
   	int i;
   	if (L.length == 0)
   		return ERROR;
   	for (i = 0; i < L.length; i++)
   		printf("%d ", L.elem[i]);
   	printf("\n");
   	return OK;
   }
    
   Status ListConverse_Sq(SqList &L)
   {
   	ElemType temp;
   	int i;
   	if (L.length == 0)
   		return ERROR;
   	for (i = 0; i < L.length; i++)
   	{
   		temp = L.elem[i];
   		L.elem[i] = L.elem[L.length - 1 - i];
   		L.elem[L.length - 1 - i] = temp;
   	}
   	return OK;
   }
    
   void main()
   {
   	SqList L;
   	printf("Initialize the sequential list!");
   	InitList_Sq(L);
   	if (L.length == 0)
   		printf("The sequential list is empty!\n");
   	printf("Create the sequential list!\n");
   	ListCreate_Sq(L, 5);
   	printf("Output all elements of the sequential list!\n");
   	ListOutput_Sq(L);
   	ListConverse_Sq(L);
   	printf("Output all converse elements of the sequential list\n");
   	ListOutput_Sq(L);
    
   	int j;cin >> j;
   	system("puase");
   }
   ```

   

1. 结构：带头结点线性链表

2. 目的：逆置，不另设新空间

3. 代码如下：

   ```c
   #include<stdio.h>
   #include<stdlib.h>
   #include<time.h>
   #include<iostream>
   using namespace std;
   #define TRUE 1
   #define FALSE 0
   #define OK 1
   #define ERROR 0
   #define OVERFLOW -2
    
   typedef int Status;
   typedef int ElemType;
   typedef struct LNode {
   	ElemType data;
   	struct LNode *next;
   }LNode,*LinkList;
    
    
   void CreateList_L(LinkList &L, int n)
   {
   	LinkList p, q;
   	int i;
   	L = (LinkList)malloc(sizeof(LNode));
   	q = L;
   	srand(time(0));
   	for (i = 1; i <= n; i++)
   	{
   		p = (LinkList)malloc(sizeof(LNode));
   		p->data = rand() % 90 + 10;
   		q->next = p;
   		q = q->next;
   	}
   	q->next = NULL;
   }
    
   Status OutputList_L(LinkList L)
   {
   	LinkList p = L->next;
   	if (p == NULL)
   		return ERROR;
   	while (p != NULL)
   	{
   		printf("%d ", p->data);
   		p = p->next;
   	}
   	printf("\n");
   	return OK;
   }
    
   Status ListConverse_L(LinkList &L)
   {
   	LinkList p, q;
   	p = L->next;
   	L->next=NULL;
   	
   	while (p!=NULL)
   	{
   		q = p;
   		p = p->next;
   		q->next = L->next;
   		L->next=q;
   	    
   	}
   	cout << "OK" << endl;
   	return OK;
   }
    
   void main()
   {
   	LinkList L;
   	printf("Create the linked list,");
   	CreateList_L(L, 5);
   	printf("Output all elements of the linked list!\n");
   	OutputList_L(L);
   	ListConverse_L(L);
   	printf("Output all converse elements of the linked list!\n");
   	OutputList_L(L);
   	int j;
   	cin >> j;
    
   }
   ```

   

1. 结构：线性表动态分配顺序存储结构

2. 目的：实现顺序表中数据元素按值非递减排列

3. 代码如下：

   ```c
   #include<stdio.h>
   #include<stdlib.h>
   #include<time.h>
    
   #define TURE 1
   #define FALSE 0
   #define OK 1
   #define ERROR 0
   #define OVERFLOW -2
   #define LIST_INIT_SIZE 100
   #define LISTINCREMENT 10
    
   typedef int Status;
   typedef int ElemType;
   typedef struct
   {
   	ElemType *elem;
   	int length;
   	int listsize;
   }SqList;
    
   Status InitList_Sq(SqList &L)
   {
   	L.elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));
   	if (!L.elem)
   		return OVERFLOW;
   	L.length = 0;
   	L.listsize = LIST_INIT_SIZE;
   	return OK;
   }
    
   Status ListCreate_Sq(SqList &L, int n)
   {
   	int i;
   	srand(time(0));
   	for (i = 0; i < n; i++)
   	{
   		L.elem[i] = rand() % 90 + 10;
   		++L.length;
   	}
   	if (L.length == 0)
   		return ERROR;
   	return OK;
   }
    
   Status ListOutput_Sq(SqList L)
   {
   	int i;
   	if (L.length == 0)
   		return ERROR;
   	for (i = 0; i < L.length; i++)
   		printf("%d ", L.elem[i]);
   	printf("\n");
   	return OK;
   }
    
    
    
    
   int Partition(SqList &L, int low, int high)
   {
   	int temp = L.elem[low];
   	int pivotkey = L.elem[low];
   	while (low < high)
   	{
   		while (low < high&&L.elem[high] >= pivotkey)
   			--high;
   	   L.elem[low] = L.elem[high];
   		while (low < high&&L.elem[low] <= pivotkey)
   			++low;
   		L.elem[high] = L.elem[low];
   	}
   	L.elem[low] = temp;
   	return low;
   }
    
   void QSort(SqList &L, int low, int high)
   {
   	if (low < high)
   	{
   		int pivotloc = Partition(L, low, high);
   		QSort(L, low, pivotloc - 1);
   		QSort(L, pivotloc + 1, high);
   	}
   }
    
   void ListSort_Sq(SqList &L)
   {
   	QSort(L, 0, L.length-1 );
   }
    
    
   void main()
   {
   	SqList L;
   	InitList_Sq(L);
   	if (L.length == 0)
   		printf("The sequential list is empty!\n");
   	ListCreate_Sq(L, 5);
   	ListOutput_Sq(L);
   	ListSort_Sq(L);
   	printf("Sorted:\n");
   	ListOutput_Sq(L);
   	system("pause");
   }
   ```



1. 结构：带头结点的线性链表L

2. 目的：数据元素按值非递减排列

3. 代码如下：

   ```c
   #include<stdio.h>
   #include<stdlib.h>
   #include<time.h>
   #define TRUE 1
   #define FALSE 0
   #define OK 1
   #define ERROR 0
   #define OVERFLOW -2
   typedef int Status;
   typedef int ElemType;
   typedef struct LNode
   {
   	ElemType data;
   	struct LNode *next;
   }LNode,*LinkList;
    
   void CreateList_L(LinkList &L, int n)
   {
   	LinkList p, q;
   	int i;
   	L = (LinkList)malloc(sizeof(LNode));
   	q = L;
   	srand(time(0));
   	for (i = 1; i <= n; i++)
   	{
   		p = (LinkList)malloc(sizeof(LNode));
   		p->data = rand() % 90 + 10;
   		q->next = p;
   		q = q->next;
   	}
   	q->next = NULL;
    
   }
    
   Status OutputList_L(LinkList L)
   {
   	LinkList p = L->next;
   	if (p == NULL)
   		return ERROR;
   	while (p != NULL)
   	{
   		printf("%d ", p->data);
   		p = p->next;
   	}
   	printf("\n");
   	return OK;
   }
    
   Status result(LinkList L, int n)
   {
   	LinkList p = L;
   	for (int i = 0; i < n; i++)
   	{
   		p = p->next;
   	}
   	return p->data;
   }
    
   LinkList par(LinkList L, int n)
   {
   	LinkList p = L;
   	for (int i = 0; i < n; i++)
   	{
   		p = p->next;
   	}
   	return p;
   }
    
    
   int Partition(LinkList &L, int low, int high)
   {
   	int temp = result(L,low);
   	int pivotkey = result(L,low);
   	LinkList p, q;
   	
   	while (low < high)
   	{
   		p = par(L, low);
   		q = par(L, high);
   		while (low < high && q->data >= pivotkey)
   		{
    
   			--high;
   			q = par(L, high);
   		}
   		
   		p->data = q->data;
   		
   		//(L + low)->data = (L + high)->data;
   		while (low < high && p->data <= pivotkey)
   		{
   			
   			++low;
   			p = par(L, low);
   		}
   		
   		q->data = p->data;
   		//(L + high)->data = (L + low)->data;
   	}
   	p = par(L, low);
   	p->data = temp;
   	//(L + low)->data = temp;
   	return low;
   }
    
   void QSort(LinkList &L, int low, int high)
   {
   	if (low < high)
   	{
   		int pivotloc = Partition(L, low, high);
   		
   		QSort(L, low, pivotloc - 1);
   		QSort(L, pivotloc + 1, high);
   	}
   }
    
   void ListSort_Sq(LinkList &L)
   {
   	LinkList p = L->next;
   	int i = 0;
   	while (p != NULL)
   	{
   		++i;
   		p = p->next;
   	}
   	
   	QSort(L, 1, i);
   }
    
   void main()
   {
   	LinkList L;
   	CreateList_L(L, 5);
   	OutputList_L(L);
   	ListSort_Sq(L);
   	printf("Sorted:");
   	OutputList_L(L);
   	system("pause");
   }
   ```

   