---
title: 有向图、无向图、有向网、无向网（邻接矩阵）
tags:
  - C
  - data structure
  - Algorithm
  - Graph

categories: 数据结构
comments: false
---



教材：严版数据结构

页码：P162

算法： 7.1-7.2

代码如下：

<!-- more -->

```c
#include<stdio.h>
#include<iostream>
#include<stdlib.h>
#include<limits.h>
#include<iomanip>
 
using namespace std;
 
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2
#define INFINITY INT_MAX //最大值
#define MAX_VERTEX_NUM 20 //最大顶点个数
typedef int Status;
typedef int VRType;
typedef int InfoType;
//{有向图，有向网，无向图，无向网}
typedef enum{DG,DN,UDG,UDN}GraphKind;
 
typedef struct ArcCell {
	VRType adj;//VRType是顶点关系类型。对无权图，用1或0
	//表示相邻否；对带权图，则为权值类型
	InfoType *info;//该弧相关信息的指针
}ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
 
typedef char VertexType;
typedef struct {
	VertexType vexs[MAX_VERTEX_NUM];//顶点向量
	AdjMatrix arcs;//邻接矩阵
	int vexnum, arcnum;//图的当前顶点数和弧数
	GraphKind kind;//图的种类标志
}MGraph;
 
//在G中找到v对应的顶点位置
int LocateVex(MGraph G, char v)
{
	int i;
	for (i = 0; i < G.vexnum; i++)
	{
		if (G.vexs[i] == v)
		{
			return i;
		}
	}
	return -1;
}
 
/*
  算法7.2
  采用数组（邻接矩阵）表示法，构造无向网G
*/
Status CreateUDN(MGraph &G)
{
	int i, j, k, w;
	VertexType v1, v2;
	cout << "输入顶点数G.vexnum:";
	cin >> G.vexnum;
	cout << "输入边数G.arcnum:";
	cin >> G.arcnum;
	getchar();
	for (i = 0; i < G.vexnum; i++)
	{
		cout << "输入顶点G.vexs[" << i << "]" << endl;
		cin >> G.vexs[i];
		getchar();
	}//构造顶点向量
 
	//初始化邻接矩阵
	for (i = 0; i < G.vexnum; i++)
	{
		for (j = 0; j < G.vexnum; j++)
		{
			G.arcs[i][j].adj = INFINITY;
			G.arcs[i][j].info = NULL;
		}
	}
	//构造邻接矩阵
	for (k = 0; k < G.arcnum; ++k)
	{
		cout << "输入第" << k + 1 << "条边vi、vj和权值w(int):" << endl;
		//输入一条边依附的顶点及权值
		cin >> v1;
		cin >> v2;
		cin >> w;
		getchar();
		//确定v1和v2在G中的位置
		i = LocateVex(G, v1);
		j = LocateVex(G, v2);
		G.arcs[i][j].adj = w;//弧<v1,v2>的权值
		//置<v1,v2>的对称弧<v2,v1>
		G.arcs[j][i].adj = G.arcs[i][j].adj;
	 }
	return OK;
}
 
Status CreateDN(MGraph &G)
{
	int i, j, k, w;
	VertexType v1, v2;
	cout << "输入顶点数G.vexnum:";
	cin >> G.vexnum;
	cout << "输入边数G.arcnum:";
	cin >> G.arcnum;
	getchar();
	for (i = 0; i < G.vexnum; i++)
	{
		cout << "输入顶点G.vexs[" << i << "]" << endl;
		cin >> G.vexs[i];
		getchar();
	}//构造顶点向量
 
	 //初始化邻接矩阵
	for (i = 0; i < G.vexnum; i++)
	{
		for (j = 0; j < G.vexnum; j++)
		{
			G.arcs[i][j].adj = INFINITY;
			G.arcs[i][j].info = NULL;
		}
	}
	//构造邻接矩阵
	for (k = 0; k < G.arcnum; ++k)
	{
		cout << "输入第" << k + 1 << "条边vi、vj和权值w(int):" << endl;
		//输入一条边依附的顶点及权值
		cin >> v1;
		cin >> v2;
		cin >> w;
		getchar();
		//确定v1和v2在G中的位置
		i = LocateVex(G, v1);
		j = LocateVex(G, v2);
		G.arcs[i][j].adj = w;//弧<v1,v2>的权值
	}
	return OK;
}
/*
有向图的构造
*/
Status CreateDG(MGraph &G)
{
	int i, j, k, w;
	VertexType v1, v2;
	cout << "输入顶点数G.vexnum:";
	cin >> G.vexnum;
	cout << "输入边数G.arcnum:";
	cin >> G.arcnum;
	getchar();
	for (i = 0; i < G.vexnum; i++)
	{
		cout << "输入顶点G.vexs[" << i << "]" << endl;
		cin >> G.vexs[i];
		getchar();
	}//构造顶点向量
 
	 //初始化邻接矩阵
	for (i = 0; i < G.vexnum; i++)
	{
		for (j = 0; j < G.vexnum; j++)
		{
			G.arcs[i][j].adj = 0;
			G.arcs[i][j].info = NULL;
		}
	}
	//构造邻接矩阵
	for (k = 0; k < G.arcnum; ++k)
	{
		cout << "输入第" << k + 1 << "条边vi、vj:" << endl;
		cin >> v1;
		cin >> v2;
		getchar();
		//确定v1和v2在G中的位置
		i = LocateVex(G, v1);
		j = LocateVex(G, v2);
		G.arcs[i][j].adj = 1;//1代表可达，0代表不可达
	}
	return OK;
}
/*
无向图的构造
*/
Status CreateUDG(MGraph &G)
{
	int i, j, k, w;
	VertexType v1, v2;
	cout << "输入顶点数G.vexnum:";
	cin >> G.vexnum;
	cout << "输入边数G.arcnum:";
	cin >> G.arcnum;
	getchar();
	for (i = 0; i < G.vexnum; i++)
	{
		cout << "输入顶点G.vexs[" << i << "]" << endl;
		cin >> G.vexs[i];
		getchar();
	}//构造顶点向量
 
	 //初始化邻接矩阵
	for (i = 0; i < G.vexnum; i++)
	{
		for (j = 0; j < G.vexnum; j++)
		{
			G.arcs[i][j].adj = 0;
			G.arcs[i][j].info = NULL;
		}
	}
	//构造邻接矩阵
	for (k = 0; k < G.arcnum; ++k)
	{
		cout << "输入第" << k + 1 << "条边vi、vj:" << endl;
		cin >> v1;
		cin >> v2;
		getchar();
		//确定v1和v2在G中的位置
		i = LocateVex(G, v1);
		j = LocateVex(G, v2);
		G.arcs[i][j].adj = 1;//1代表可达，0代表不可达
		G.arcs[j][i].adj = G.arcs[i][j].adj;
	}
	return OK;
}
/*
算法7.1
采用数组（邻接矩阵）表示法，构造图G。
*/
Status CreateGraph(MGraph &G)
{
	cout << "请输入图的种类：0表示DG，1表示DN，2表示UDG，3表示UDN" << endl;
	int x;
	cin >> x;
	G.kind=(GraphKind)x;
	switch (G.kind)
	{
	case DG:
		return CreateDG(G);
	case DN:
		return CreateDN(G);
	case UDG:
		return CreateUDG(G);
	case UDN:return CreateUDN(G);
	default:return ERROR;
	}
}
 
void list(MGraph G)
{
	int i, j;
	cout << "输出邻接矩阵：" << endl;
	for (i = 0; i < G.vexnum; ++i)
	{
		cout << G.vexs[i] << "----";
		for (j = 0; j < G.vexnum; ++j)
		{
			if (G.arcs[i][j].adj == INFINITY)
				cout << setw(4) << "∞";
			else
				cout << setw(4) << G.arcs[i][j].adj;			
		}
		cout << endl;
	}
}
 
void main()
{
	MGraph G;
	int x=1;
	while (x)
	{
		CreateGraph(G);
		list(G);
		cout << "是否继续(1、继续，0、退出)";
			cin >> x;
			cout << endl;
	}
	system("pause");
}
```

